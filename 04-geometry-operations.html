<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="An introductory resource for working with geographic data in Python">

<title>Geocomputation with Python - 4&nbsp; Geometry operations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-raster-vector.html" rel="next">
<link href="./03-spatial-operations.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-geometry-operations.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometry operations</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Geocomputation with Python</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/geocompx/geocompy/" rel="" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
              <i class="bi bi-bi-linkedin pe-1"></i>
            LinkedIn
            </a>
          </li>
      </ul>
    </div>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preface.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-spatial-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Geographic data in Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-attribute-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Attribute data operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-spatial-operations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatial data operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-geometry-operations.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometry operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-raster-vector.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Raster-vector interactions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-reproj.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Reprojecting geographic data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-read-write-plot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Geographic data I/O</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Making maps with Python</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
  <h2 class="anchored">Note: The book is under construction 🏗</h2>
  <ul>
    <li><a href="https://github.com/geocompr/py/issues" class="nav-link active" data-scroll-target="https\://github.com/geocompr/py/issues">Open an issue ❔</a></li>
    <li><a href="https://discord.gg/PMztXYgNxp" class="nav-link" data-scroll-target="https\://discord.gg/PMztXYgNxp">Chat on Discord 📣</a></li>
  </ul>
  <hr>
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#prerequisites" id="toc-prerequisites" class="nav-link" data-scroll-target="#prerequisites"><span class="header-section-number">4.1</span> Prerequisites</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">4.2</span> Introduction</a></li>
  <li><a href="#sec-geo-vec" id="toc-sec-geo-vec" class="nav-link" data-scroll-target="#sec-geo-vec"><span class="header-section-number">4.3</span> Geometric operations on vector data</a>
  <ul>
  <li><a href="#sec-simplification" id="toc-sec-simplification" class="nav-link" data-scroll-target="#sec-simplification"><span class="header-section-number">4.3.1</span> Simplification</a></li>
  <li><a href="#centroids" id="toc-centroids" class="nav-link" data-scroll-target="#centroids"><span class="header-section-number">4.3.2</span> Centroids</a></li>
  <li><a href="#sec-buffers" id="toc-sec-buffers" class="nav-link" data-scroll-target="#sec-buffers"><span class="header-section-number">4.3.3</span> Buffers</a></li>
  <li><a href="#sec-affine-transformations" id="toc-sec-affine-transformations" class="nav-link" data-scroll-target="#sec-affine-transformations"><span class="header-section-number">4.3.4</span> Affine transformations</a></li>
  <li><a href="#sec-clipping" id="toc-sec-clipping" class="nav-link" data-scroll-target="#sec-clipping"><span class="header-section-number">4.3.5</span> Pairwise geometry-generating operations</a></li>
  <li><a href="#subsetting-and-clipping" id="toc-subsetting-and-clipping" class="nav-link" data-scroll-target="#subsetting-and-clipping"><span class="header-section-number">4.3.6</span> Subsetting and clipping</a></li>
  <li><a href="#sec-geometry-unions" id="toc-sec-geometry-unions" class="nav-link" data-scroll-target="#sec-geometry-unions"><span class="header-section-number">4.3.7</span> Geometry unions</a></li>
  <li><a href="#sec-type-transformations" id="toc-sec-type-transformations" class="nav-link" data-scroll-target="#sec-type-transformations"><span class="header-section-number">4.3.8</span> Type transformations</a></li>
  </ul></li>
  <li><a href="#sec-geo-ras" id="toc-sec-geo-ras" class="nav-link" data-scroll-target="#sec-geo-ras"><span class="header-section-number">4.4</span> Geometric operations on raster data</a>
  <ul>
  <li><a href="#geometric-intersections" id="toc-geometric-intersections" class="nav-link" data-scroll-target="#geometric-intersections"><span class="header-section-number">4.4.1</span> Geometric intersections</a></li>
  <li><a href="#sec-extent-and-origin" id="toc-sec-extent-and-origin" class="nav-link" data-scroll-target="#sec-extent-and-origin"><span class="header-section-number">4.4.2</span> Extent and origin</a></li>
  <li><a href="#sec-raster-agg-disagg" id="toc-sec-raster-agg-disagg" class="nav-link" data-scroll-target="#sec-raster-agg-disagg"><span class="header-section-number">4.4.3</span> Aggregation and disaggregation</a></li>
  <li><a href="#sec-raster-resampling" id="toc-sec-raster-resampling" class="nav-link" data-scroll-target="#sec-raster-resampling"><span class="header-section-number">4.4.4</span> Resampling</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">4.5</span> Exercises</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/geocompx/geocompy/edit/main/04-geometry-operations.qmd" class="toc-action">Edit this page</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="geometric-operations" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometry operations</span></span></h1>
</div>

<!--
-->


<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="prerequisites" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="prerequisites"><span class="header-section-number">4.1</span> Prerequisites</h2>
<p>Let’s import the required packages:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shapely</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> topojson <span class="im">as</span> tp</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.warp</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.plot</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio.mask</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and load the sample data for this chapter:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>seine <span class="op">=</span> gpd.read_file(<span class="st">'data/seine.gpkg'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>us_states <span class="op">=</span> gpd.read_file(<span class="st">'data/us_states.gpkg'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>nz <span class="op">=</span> gpd.read_file(<span class="st">'data/nz.gpkg'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>src <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/dem.tif'</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>src_elev <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'data/elev.tif'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="introduction" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="introduction"><span class="header-section-number">4.2</span> Introduction</h2>
<p>So far the book has explained the structure of geographic datasets (<a href="01-spatial-data.html"><span>Chapter&nbsp;1</span></a>), and how to manipulate them based on their non-geographic attributes (<a href="02-attribute-operations.html"><span>Chapter&nbsp;2</span></a>) and spatial relations (<a href="03-spatial-operations.html"><span>Chapter&nbsp;3</span></a>). This chapter focusses on manipulating the geographic elements of geographic objects, for example by simplifying and converting vector geometries, and by cropping raster datasets. After reading it you should understand and have control over the geometry column in vector layers and the extent and geographic location of pixels represented in rasters in relation to other geographic objects.</p>
<p><a href="#sec-geo-vec"><span>Section&nbsp;4.3</span></a> covers transforming vector geometries with ‘unary’ and ‘binary’ operations. Unary operations work on a single geometry in isolation, including simplification (of lines and polygons), the creation of buffers and centroids, and shifting/scaling/rotating single geometries using ‘affine transformations’ (<a href="#sec-simplification"><span>Section&nbsp;4.3.1</span></a> to <a href="#sec-affine-transformations"><span>Section&nbsp;4.3.4</span></a>). Binary transformations modify one geometry based on the shape of another, including clipping and geometry unions, covered in <a href="#sec-clipping"><span>Section&nbsp;4.3.5</span></a> and <a href="#sec-geometry-unions"><span>Section&nbsp;4.3.7</span></a>, respectively. Type transformations (from a polygon to a line, for example) are demonstrated in Section <a href="#sec-type-transformations"><span>Section&nbsp;4.3.8</span></a>.</p>
<p><a href="#sec-geo-ras"><span>Section&nbsp;4.4</span></a> covers geometric transformations on raster objects. This involves changing the size and number of the underlying pixels, and assigning them new values. It teaches how to change the extent and the origin of a raster “manually” (<a href="#sec-extent-and-origin"><span>Section&nbsp;4.4.2</span></a>), how to change the resolution in fixed “steps” through aggregation and disaggregation (<a href="#sec-raster-agg-disagg"><span>Section&nbsp;4.4.3</span></a>), and finally how to resample a raster into any existing template, which is the most general and often most practical approach (<a href="#sec-raster-resampling"><span>Section&nbsp;4.4.4</span></a>). These operations are especially useful if one would like to align raster datasets from diverse sources. Aligned raster objects share a one-to-one correspondence between pixels, allowing them to be processed using map algebra operations (<a href="03-spatial-operations.html#sec-raster-local-operations"><span>Section&nbsp;3.4.3</span></a>).</p>
<p>In the next chapter (<a href="05-raster-vector.html"><span>Chapter&nbsp;5</span></a>), we deal with the special case of geometry operations that involve both a raster and a vector layer together. It shows how raster values can be ‘masked’ and ‘extracted’ by vector geometries. Importantly it shows how to ‘polygonize’ rasters and ‘rasterize’ vector datasets, making the two data models more interchangeable.</p>
</section>
<section id="sec-geo-vec" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-geo-vec"><span class="header-section-number">4.3</span> Geometric operations on vector data</h2>
<p>This section is about operations that in some way change the geometry of vector layers. It is more advanced than the spatial data operations presented in the previous chapter (in <a href="03-spatial-operations.html#sec-spatial-vec"><span>Section&nbsp;3.3</span></a>), because here we drill down into the geometry: the functions discussed in this section work on the geometric part (the geometry column, which is a <code>GeoSeries</code> object), either as standalone object or as part of a <code>GeoDataFrame</code>.</p>
<section id="sec-simplification" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="sec-simplification"><span class="header-section-number">4.3.1</span> Simplification</h3>
<p>Simplification is a process for generalization of vector objects (lines and polygons) usually for use in smaller scale maps. Another reason for simplifying objects is to reduce the amount of memory, disk space and network bandwidth they consume: it may be wise to simplify complex geometries before publishing them as interactive maps. The <code>geopandas</code> package provides the <code>.simplify</code> method, which uses the GEOS implementation of the Douglas-Peucker algorithm to reduce the vertex count. <code>.simplify</code> uses the <code>tolerance</code> to control the level of generalization in map units (see Douglas and Peucker 1973 for details).</p>
<p>For example, a simplified geometry of a <code>"LineString"</code> geometry, representing the river Seine and tributaries, using tolerance of <code>2000</code> meters, can created using the following command:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>seine_simp <span class="op">=</span> seine.simplify(<span class="dv">2000</span>) <span class="co"># meters</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Figure <a href="#fig-simplify-lines">Figure&nbsp;<span>4.1</span></a> illustrates the input and the result of the simplification:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>seine.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>seine_simp.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Simplified (d=2000 m)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-simplify-lines" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-simplify-lines-output-1.png" width="428" height="206" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.1: Comparison of the original and simplified geometry of the seine object.</figcaption>
</figure>
</div>
</div>
</div>
<p>The resulting <code>seine_simp</code> object is a copy of the original <code>seine</code> but with fewer vertices. This is apparent, with the result being visually simpler (<a href="#fig-simplify-lines">Figure&nbsp;<span>4.1</span></a>, right) and consuming less memory than the original object, as verified below:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Original: </span><span class="sc">{</span>sys<span class="sc">.</span>getsizeof(seine)<span class="sc">}</span><span class="ss"> bytes'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original: 374 bytes</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Simplified: </span><span class="sc">{</span>sys<span class="sc">.</span>getsizeof(seine_simp)<span class="sc">}</span><span class="ss"> bytes'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Simplified: 188 bytes</code></pre>
</div>
</div>
<p>Simplification is also applicable for polygons. This is illustrated using <code>us_states</code>, representing the contiguous United States. As we show in <a href="06-reproj.html"><span>Chapter&nbsp;6</span></a>, GEOS assumes that the data is in a projected CRS and this could lead to unexpected results when using a geographic CRS. Therefore, the first step is to project the data into some adequate projected CRS, such as US National Atlas Equal Area (epsg = <code>2163</code>) (on the left in Figure <a href="#fig-simplify-polygons">Figure&nbsp;<span>4.2</span></a>):</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>us_states2163 <span class="op">=</span> us_states.to_crs(<span class="dv">2163</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The <code>.simplify</code> method from <code>geopandas</code> works the same way with a <code>"Polygon"</code>/<code>"MultiPolygon"</code> layer such as <code>us_states2163</code>:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>us_states_simp1 <span class="op">=</span> us_states2163.simplify(<span class="dv">100000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A limitation with <code>.simplify</code> is that it simplifies objects on a per-geometry basis. This means the “topology” is lost, resulting in overlapping and “holey” areal units illustrated in Figure <a href="#fig-simplify-polygons">Figure&nbsp;<span>4.2</span></a> (middle panel). The <code>toposimplify</code> function from <code>topojson</code> provides an alternative that overcomes this issue. By <a href="https://mattijn.github.io/topojson/example/settings-tuning.html#simplify_algorithm">default</a> it uses the Douglas-Peucker algorithm like the <code>.simplify</code> method. Another algorithm known as Visvalingam-Whyatt, which overcomes some limitations of the Douglas-Peucker algorithm (Visvalingam and Whyatt 1993), is also available in <code>toposimplify</code>. The main advanatage of <code>toposimplify</code>, however, is that it is topologically “aware”. That is, it simplifies the combined borders of the polygons (rather than each polygon on its own), thus ensuring that the overlap is maintained. The following code chunk uses this function to simplify <code>us_states2163</code>:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>topo <span class="op">=</span> tp.Topology(us_states2163, prequantize<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>us_states_simp2 <span class="op">=</span> topo.toposimplify(<span class="dv">100000</span>).to_gdf()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/usr/local/lib/python3.11/site-packages/topojson/core/dedup.py:107: RuntimeWarning: invalid value encountered in cast
  data["bookkeeping_shared_arcs"] = array_bk_sarcs.astype(np.int64).tolist()</code></pre>
</div>
</div>
<p>Figure <a href="#fig-simplify-polygons">Figure&nbsp;<span>4.2</span></a> demonstrates the two simplification methods applied to <code>us_states2163</code>.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>us_states2163.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>us_states_simp1.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>us_states_simp2.plot(ax<span class="op">=</span>axes[<span class="dv">2</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">"Original"</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">"Simplified (w/ GeoPandas)"</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">"Simplified (w/ TopoJSON)"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-simplify-polygons" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-simplify-polygons-output-1.png" width="654" height="204" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.2: Polygon simplification in action, comparing the original geometry of the contiguous United States with simplified versions, generated with functions from the GeoPandas (middle), and TopoJSON (right), packages.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="centroids" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="centroids"><span class="header-section-number">4.3.2</span> Centroids</h3>
<p>Centroid operations identify the center of geographic objects. Like statistical measures of central tendency (including mean and median definitions of ‘average’), there are many ways to define the geographic center of an object. All of them create single point representations of more complex vector objects.</p>
<p>The most commonly used centroid operation is the geographic centroid. This type of centroid operation (often referred to as ‘the centroid’) represents the center of mass in a spatial object (think of balancing a plate on your finger). Geographic centroids have many uses, for example to create a simple point representation of complex geometries, or to estimate distances between polygons. Centroids of the geometries in a <code>GeoSeries</code> or a <code>GeoDataFrame</code> are accessible through the <code>.centroid</code> property, as demonstrated in the code below, which generates the geographic centroids of regions in New Zealand and tributaries to the River Seine, illustrated with black points in <a href="#fig-centroid-pnt-on-surface">Figure&nbsp;<span>4.3</span></a>.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nz_centroid <span class="op">=</span> nz.centroid</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>seine_centroid <span class="op">=</span> seine.centroid</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sometimes the geographic centroid falls outside the boundaries of their parent objects (think of a doughnut). In such cases point on surface operations can be used to guarantee the point will be in the parent object (e.g., for labeling irregular multipolygon objects such as island states), as illustrated by the red points in <a href="#fig-centroid-pnt-on-surface">Figure&nbsp;<span>4.3</span></a>. Notice that these red points always lie on their parent objects. They were created with the <code>representative_point</code> method, as follows:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nz_pos <span class="op">=</span> nz.representative_point()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>seine_pos <span class="op">=</span> seine.representative_point()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The centroids and points in surface are illustrated in <a href="#fig-centroid-pnt-on-surface">Figure&nbsp;<span>4.3</span></a>:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'white'</span>, edgecolor<span class="op">=</span><span class="st">'lightgrey'</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>nz_centroid.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>nz_pos.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>seine.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'grey'</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>seine_pos.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>seine_centroid.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'None'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>fig.suptitle(<span class="st">"Represenative points in red and centroids in black"</span>, y<span class="op">=</span><span class="fl">0.85</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>fig.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-centroid-pnt-on-surface" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-centroid-pnt-on-surface-output-1.png" width="470" height="377" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.3: Centroids (black) and points on surface red of New Zealand and Seine datasets.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-buffers" class="level3" data-number="4.3.3">
<h3 data-number="4.3.3" class="anchored" data-anchor-id="sec-buffers"><span class="header-section-number">4.3.3</span> Buffers</h3>
<p>Buffers are polygons representing the area within a given distance of a geometric feature: regardless of whether the input is a point, line or polygon, the output is a polygon. Unlike simplification (which is often used for visualization and reducing file size) buffering tends to be used for geographic data analysis. How many points are within a given distance of this line? Which demographic groups are within travel distance of this new shop? These kinds of questions can be answered and visualized by creating buffers around the geographic entities of interest.</p>
<p><a href="#fig-buffers">Figure&nbsp;<span>4.4</span></a> illustrates buffers of different sizes (5 and 50 km) surrounding the river Seine and tributaries. These buffers were created with commands below, which show that the <code>.buffer</code> method, applied to a <code>GeoSeries</code> (or <code>GeoDataFrame</code>) requires one important argument: the buffer distance, provided in the units of the CRS (in this case meters):</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>seine_buff_5km <span class="op">=</span> seine.<span class="bu">buffer</span>(<span class="dv">5000</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>seine_buff_50km <span class="op">=</span> seine.<span class="bu">buffer</span>(<span class="dv">50000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The 5 and 50 km buffers are visualized in <a href="#fig-buffers">Figure&nbsp;<span>4.4</span></a>:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>seine_buff_5km.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>[<span class="st">'red'</span>, <span class="st">'green'</span>, <span class="st">'blue'</span>])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>seine_buff_50km.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span>[<span class="st">'red'</span>, <span class="st">'green'</span>, <span class="st">'blue'</span>])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'5 km buffer'</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'50 km buffer'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-buffers" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-buffers-output-1.png" width="422" height="200" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.4: Buffers around the Seine dataset of 5 km (left) and 50 km (right). Note the colors, which reflect the fact that one buffer is created per geometry feature.</figcaption>
</figure>
</div>
</div>
</div>
<p>Note that both <code>.centroid</code> and <code>.buffer</code> return a <code>GeoSeries</code> object, even when the input is a <code>GeoDataFrame</code>:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>seine_buff_5km</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>0    POLYGON ((657550.332 6852587.97...
1    POLYGON ((517151.801 6930724.10...
2    POLYGON ((701519.740 6813075.49...
dtype: geometry</code></pre>
</div>
</div>
<p>In the common scenario when the original attributes of the input features need to be retained, you can replace the existing geometry with the new <code>GeoSeries</code> as in:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>seine_buff_5km <span class="op">=</span> seine.copy()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>seine_buff_5km.geometry <span class="op">=</span> seine.<span class="bu">buffer</span>(<span class="dv">5000</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>seine_buff_5km</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">name</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Marne</td>
<td>POLYGON ((657550.332 6852587.97...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Seine</td>
<td>POLYGON ((517151.801 6930724.10...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>Yonne</td>
<td>POLYGON ((701519.740 6813075.49...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="sec-affine-transformations" class="level3" data-number="4.3.4">
<h3 data-number="4.3.4" class="anchored" data-anchor-id="sec-affine-transformations"><span class="header-section-number">4.3.4</span> Affine transformations</h3>
<p>Affine transformation is any transformation that preserves lines and parallelism. However, angles or length are not necessarily preserved. Affine transformations include, among others, shifting (translation), scaling and rotation. Additionally, it is possible to use any combination of these. Affine transformations are an essential part of geocomputation. For example, shifting is needed for labels placement, scaling is used in non-contiguous area cartograms, and many affine transformations are applied when reprojecting or improving the geometry that was created based on a distorted or wrongly projected map.</p>
<p>The <code>geopandas</code> package implements affine transformation, for objects of classes <code>GeoSeries</code> and <code>GeoDataFrame</code>. In both cases, the method is applied on the <code>GeoSeries</code> part, returning a new <code>GeoSeries</code> of transformed geometries.</p>
<p>Affine transformations of <code>GeoSeries</code> can be done using the <code>.affine_transform</code> method, which is a wrapper around the <code>shapely.affinity.affine_transform</code> function. According to the <a href="https://shapely.readthedocs.io/en/stable/manual.html#shapely.affinity.affine_transform">documentation</a>, a 2D affine transformation requires a six-parameter list <code>[a,b,d,e,xoff,yoff]</code> which represents the following equations for transforming the coordinates (<a href="#eq-affine1">Equation&nbsp;<span>4.1</span></a> and <a href="#eq-affine2">Equation&nbsp;<span>4.2</span></a>):</p>
<p><span id="eq-affine1"><span class="math display">\[
x' = a x + b y + x_\mathrm{off}
\tag{4.1}\]</span></span></p>
<p><span id="eq-affine2"><span class="math display">\[
y' = d x + e y + y_\mathrm{off}
\tag{4.2}\]</span></span></p>
<p>There are also simplified <code>GeoSeries</code> <a href="https://geopandas.org/en/stable/docs/user_guide/geometric_manipulations.html#affine-transformations">methods</a> for specific scenarios:</p>
<ul>
<li><code>GeoSeries.translate(xoff=0.0, yoff=0.0, zoff=0.0)</code></li>
<li><code>GeoSeries.scale(xfact=1.0, yfact=1.0, zfact=1.0, origin='center')</code></li>
<li><code>GeoSeries.rotate(angle, origin='center', use_radians=False)</code></li>
<li><code>GeoSeries.skew(angle, origin='center', use_radians=False)</code></li>
</ul>
<p>For example, <em>shifting</em> only requires the <span class="math inline">\(x_{off}\)</span> and <span class="math inline">\(y_{off}\)</span>, using <code>.translate</code>. The code below shifts the y-coordinates by 100,000 meters to the north, but leaves the x-coordinates untouched:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>nz_shift <span class="op">=</span> nz.translate(<span class="dv">0</span>, <span class="dv">100000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Scaling enlarges or shrinks objects by a factor. It can be applied either globally or locally. Global scaling increases or decreases all coordinates values in relation to the origin coordinates, while keeping all geometries topological relations intact.</p>
<p><code>Geopandas</code> implements local scaling using the <code>.scale</code> method. Local scaling treats geometries independently and requires points around which geometries are going to be scaled, e.g., centroids. In the example below, each geometry is shrunk by a factor of two around the centroids (middle panel in <a href="#fig-affine-transformations">Figure&nbsp;<span>4.5</span></a>). To achieve that, we pass the <code>0.5</code> and <code>0.5</code> scaling factors (for x and y, respectively), and the <code>'centroid'</code> option for the point of origin. (Other than <code>'centroid'</code>, it is possible to use <code>'center'</code> for the bounding box center, or specific point coordinates.)</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>nz_scale <span class="op">=</span> nz.scale(<span class="fl">0.5</span>, <span class="fl">0.5</span>, origin<span class="op">=</span><span class="st">'centroid'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Rotating the geometries can be done using the <code>.rotate</code> method. When rotating, we need to specify the rotation angle (positive values imply clockwise rotation) and the <code>origin</code> points (using the same options as in <code>scale</code>). For example, the following expression rotates <code>nz</code> by 30 degrees counter-clockwise, around the geometry centroids:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>nz_rotate <span class="op">=</span> nz.rotate(<span class="op">-</span><span class="dv">30</span>, origin<span class="op">=</span><span class="st">'centroid'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="#fig-affine-transformations">Figure&nbsp;<span>4.5</span></a> shows the original layer <code>nz</code>, and the shifting, scaling and rotation results.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>nz_shift.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], color<span class="op">=</span><span class="st">'red'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>nz_scale.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], color<span class="op">=</span><span class="st">'red'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>nz.plot(ax<span class="op">=</span>axes[<span class="dv">2</span>], color<span class="op">=</span><span class="st">'lightgrey'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>nz_rotate.plot(ax<span class="op">=</span>axes[<span class="dv">2</span>], color<span class="op">=</span><span class="st">'red'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Shift'</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Scale'</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'Rotate'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-affine-transformations" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-affine-transformations-output-1.png" width="645" height="349" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.5: Illustrations of affine transformations: shift, scale and rotate.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-clipping" class="level3" data-number="4.3.5">
<h3 data-number="4.3.5" class="anchored" data-anchor-id="sec-clipping"><span class="header-section-number">4.3.5</span> Pairwise geometry-generating operations</h3>
<p>Spatial clipping is a form of spatial subsetting that involves changes to the geometry columns of at least some of the affected features.</p>
<p>Clipping can only apply to features more complex than points: lines, polygons and their ‘multi’ equivalents. To illustrate the concept we will start with a simple example: two overlapping circles with a center point one unit away from each other and a radius of one (<a href="#fig-overlapping-circles">Figure&nbsp;<span>4.6</span></a>).</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> shapely.Point((<span class="dv">0</span>, <span class="dv">0</span>)).<span class="bu">buffer</span>(<span class="dv">1</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> shapely.Point((<span class="dv">1</span>, <span class="dv">0</span>)).<span class="bu">buffer</span>(<span class="dv">1</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>shapely.GeometryCollection([x, y])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<div id="fig-overlapping-circles" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-overlapping-circles-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.6: Overlapping polygon (circle) geometries <code>x</code> and <code>y</code></figcaption>
</figure>
</div>
</div>
</div>
<p>Imagine you want to select not one circle or the other, but the space covered by both x and y. This can be done using the <code>.intersection</code> method from <code>shapely</code>, illustrated using objects named <code>x</code> and <code>y</code> which represent the left- and right-hand circles (<a href="#fig-intersection">Figure&nbsp;<span>4.7</span></a>).</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>x.intersection(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div id="fig-intersection" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-intersection-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.7: Intersection between <code>x</code> and <code>y</code></figcaption>
</figure>
</div>
</div>
</div>
<p>The next lines of code demonstrate how this works for the <code>.difference</code> (<a href="#fig-difference">Figure&nbsp;<span>4.8</span></a>), <code>.union</code> (<a href="#fig-union">Figure&nbsp;<span>4.9</span></a>), and <code>.symmetric_difference</code> (<a href="#fig-symmetric-difference">Figure&nbsp;<span>4.10</span></a>) operators:</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>x.difference(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<div id="fig-difference" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-difference-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.8: Difference between <code>x</code> and <code>y</code> (namely, <code>x</code> “minus” <code>y</code>)</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>x.union(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<div id="fig-union" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-union-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.9: Union of <code>x</code> and <code>y</code></figcaption>
</figure>
</div>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>x.symmetric_difference(y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<div id="fig-symmetric-difference" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-symmetric-difference-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.10: Symmetric difference between <code>x</code> and <code>y</code></figcaption>
</figure>
</div>
</div>
</div>
<p>Keep in mind that <code>x</code> and <code>y</code> are interchangeable in all predictes except for <code>.difference</code>, where:</p>
<ul>
<li><code>x.difference(y)</code> means <code>x</code> minus <code>y</code>, whereas</li>
<li><code>y.difference(x)</code> means <code>y</code> minus <code>x</code>.</li>
</ul>
<p>The latter examples demontrate pairwise operations between individual <code>shapely</code> geometries. The <strong>geopandas</strong> package, as is often the case, contains wrappers of these <strong>shapely</strong> functions to be applied to multiple, or pairwise, use cases. For example, applying either of the pairwise methods on a <code>GeoSeries</code> or <code>GeoDataFrame</code> combined with a <code>shapely</code> geometry returns the pairwise (many-to-one) results.</p>
<p>Let’s demonstrate by calculating the difference of each geometry in a <code>GeoSeries</code> and a “fixed” <code>shapely</code> geometry. To creare the latter, let’s take <code>x</code> and combine it with itself translated (<a href="#sec-affine-transformations"><span>Section&nbsp;4.3.4</span></a>) to a distance of <code>1</code> or <code>2</code> units “upwards” on the y-axis:</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>geom1 <span class="op">=</span> gpd.GeoSeries([x])</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>geom2 <span class="op">=</span> geom1.translate(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>geom3 <span class="op">=</span> geom1.translate(<span class="dv">0</span>, <span class="dv">2</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>geom <span class="op">=</span> pd.concat([geom1, geom2, geom3])</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>geom</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>0    POLYGON ((1.00000 0.00000, 0.99...
0    POLYGON ((1.00000 1.00000, 0.99...
0    POLYGON ((1.00000 2.00000, 0.99...
dtype: geometry</code></pre>
</div>
</div>
<p>Here is a plot of the <code>GeoSeries</code>, with the <code>shapely</code> geometry (in red) that we will intersect with it (<a href="#fig-geom-intersection">Figure&nbsp;<span>4.11</span></a>):</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>geom.plot(color<span class="op">=</span><span class="st">'none'</span>, ax<span class="op">=</span>ax)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries(y).plot(color<span class="op">=</span><span class="st">'#FF000040'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-geom-intersection" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-geom-intersection-output-1.png" width="338" height="411" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.11: A <code>GeoSeries</code> with two circles, and a <code>shapely</code> geometry that we will “subtract” from it (in red)</figcaption>
</figure>
</div>
</div>
</div>
<p>Now, using <code>.intersection</code> automatically applies the <code>shapely</code> method of the same name on each geometry in <code>geom</code>, returning a new <code>GeoSeries</code>, which we name <code>geom_inter_y</code>, with the pairwise “intersections”. Note the empty third geometry (can you explain the meaning of this result?):</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>geom_inter_y <span class="op">=</span> geom.intersection(y)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>geom_inter_y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>0    POLYGON ((0.99518 -0.09802, 0.9...
0    POLYGON ((0.99518 0.90198, 0.98...
0                         POLYGON EMPTY
dtype: geometry</code></pre>
</div>
</div>
<p>Here is a plot of the result (<a href="#fig-geom-intersection2">Figure&nbsp;<span>4.12</span></a>):</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>geom_inter_y.plot(color<span class="op">=</span><span class="st">'none'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-geom-intersection2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-geom-intersection2-output-1.png" width="269" height="411" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.12: The output <code>GeoSeries</code>, after subtracting a <code>shapely</code> geometry using <code>.intersection</code></figcaption>
</figure>
</div>
</div>
</div>
<p>The <code>.overlay</code> method (see <a href="03-spatial-operations.html#sec-joining-incongruent-layers"><span>Section&nbsp;3.3.6</span></a>) further extends this technique, making it possible to apply many-to-many pairwise geometry generations between all pairs of two <code>GeoDataFrame</code>s. The output is a new <code>GeoDataFrame</code> with the pairwise outputs, plus the attributes of both inputs which were the inputs of the particular pairwise output geometry. See the <a href="https://geopandas.org/en/stable/docs/user_guide/set_operations.html">Set operations with overlay</a> article in the <strong>geopandas</strong> documentation for examples of <code>.overlay</code>.</p>
</section>
<section id="subsetting-and-clipping" class="level3" data-number="4.3.6">
<h3 data-number="4.3.6" class="anchored" data-anchor-id="subsetting-and-clipping"><span class="header-section-number">4.3.6</span> Subsetting and clipping</h3>
<p>Clipping objects can change their geometry but it can also subset objects, returning only features that intersect (or partly intersect) with a clipping/subsetting object. To illustrate this point, we will subset points that cover the bounding box of the circles x and y in <a href="#fig-overlapping-circles">Figure&nbsp;<span>4.6</span></a>. Some points will be inside just one circle, some will be inside both and some will be inside neither. The following code sections generates a simple random distribution of points within the extent of circles x and y, resulting in output illustrated in <a href="#fig-random-points">Figure&nbsp;<span>4.13</span></a>. We do this in two steps. First, we figure out the bounds where random points are to be generated:</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>bounds <span class="op">=</span> x.union(y).bounds</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>bounds</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>(-1.0, -1.0, 2.0, 1.0)</code></pre>
</div>
</div>
<p>Second, we use <code>np.random.uniform</code> to calculate <code>n</code> random x and y coordinates within the given bounds:</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10</span>  <span class="co">## Number of points to generate</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>coords_x <span class="op">=</span> np.random.uniform(bounds[<span class="dv">0</span>], bounds[<span class="dv">2</span>], n)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>coords_y <span class="op">=</span> np.random.uniform(bounds[<span class="dv">1</span>], bounds[<span class="dv">3</span>], n)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(coords_x, coords_y))</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>[(0.2510660141077219, -0.1616109711934104),
 (1.1609734803264744, 0.370439000793519),
 (-0.9996568755479653, -0.5910955005369651),
 (-0.0930022821044807, 0.7562348727818908),
 (-0.5597323275486609, -0.9452248136041477),
 (-0.7229842156936066, 0.34093502035680445),
 (-0.4412193658669873, -0.16539039526574606),
 (0.03668218112914312, 0.11737965689150331),
 (0.1903024226920098, -0.7192261228095325),
 (0.6164502020100708, -0.6037970218302424)]</code></pre>
</div>
</div>
<p>Third, we transform the list of coordinates into a <code>list</code> of <code>shapely</code> points:</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>pnt <span class="op">=</span> [shapely.Point(i) <span class="cf">for</span> i <span class="kw">in</span> coords]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>pnt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<pre><code>[&lt;POINT (0.251 -0.162)&gt;,
 &lt;POINT (1.161 0.37)&gt;,
 &lt;POINT (-1 -0.591)&gt;,
 &lt;POINT (-0.093 0.756)&gt;,
 &lt;POINT (-0.56 -0.945)&gt;,
 &lt;POINT (-0.723 0.341)&gt;,
 &lt;POINT (-0.441 -0.165)&gt;,
 &lt;POINT (0.037 0.117)&gt;,
 &lt;POINT (0.19 -0.719)&gt;,
 &lt;POINT (0.616 -0.604)&gt;]</code></pre>
</div>
</div>
<p>and then to a <code>GeoSeries</code>:</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>pnt <span class="op">=</span> gpd.GeoSeries(pnt)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>pnt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>0     POINT (0.25107 -0.16161)
1      POINT (1.16097 0.37044)
2    POINT (-0.99966 -0.59110)
               ...            
7      POINT (0.03668 0.11738)
8     POINT (0.19030 -0.71923)
9     POINT (0.61645 -0.60380)
Length: 10, dtype: geometry</code></pre>
</div>
</div>
<p>The result is shown in <a href="#fig-random-points">Figure&nbsp;<span>4.13</span></a>:</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> pnt.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([x]).plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)<span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([y]).plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-random-points" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-random-points-output-1.png" width="441" height="290" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.13: Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y are highlighted.</figcaption>
</figure>
</div>
</div>
</div>
<p>Now, we get back to our question: how to subset the points to only return the point that intersects with both x and y? The code chunks below demonstrate three ways to achieve the same result. We can calculate a boolean <code>Series</code>, evaluating whether each point of <code>pnt</code> intersects with the intersection of x and y:</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> pnt.intersects(x.intersection(y))</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>sel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>0     True
1    False
2    False
     ...  
7     True
8    False
9     True
Length: 10, dtype: bool</code></pre>
</div>
</div>
<p>then use it to subset <code>pnt</code> to get the result <code>pnt1</code>:</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>pnt1 <span class="op">=</span> pnt[sel]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>pnt1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>0    POINT (0.25107 -0.16161)
7     POINT (0.03668 0.11738)
9    POINT (0.61645 -0.60380)
dtype: geometry</code></pre>
</div>
</div>
<p>We can also find the intersection between the input points represented by <code>pnt</code>, using the intersection of <code>x</code> and <code>y</code> as the subsetting/clipping object. Since the second argument is an individual <code>shapely</code> geometry (<code>x.intersection(y)</code>), we get “pairwise” intersections of each <code>pnt</code> with it:</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>pnt2 <span class="op">=</span> pnt.intersection(x.intersection(y))</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>pnt2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>0    POINT (0.25107 -0.16161)
1                 POINT EMPTY
2                 POINT EMPTY
               ...           
7     POINT (0.03668 0.11738)
8                 POINT EMPTY
9    POINT (0.61645 -0.60380)
Length: 10, dtype: geometry</code></pre>
</div>
</div>
<p>The result is shown in <a href="#fig-intersection-points">Figure&nbsp;<span>4.14</span></a>:</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>base <span class="op">=</span> pnt.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([x]).plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)<span class="op">;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([y]).plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'darkgrey'</span>)<span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>pnt2.plot(ax<span class="op">=</span>base, color<span class="op">=</span><span class="st">'red'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-intersection-points" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-intersection-points-output-1.png" width="441" height="290" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.14: Randomly distributed points within the bounding box enclosing circles x and y. The point that intersects with both objects x and y are highlighted.</figcaption>
</figure>
</div>
</div>
</div>
<p>Empty geometries can be filtered out to retain the required subset, and to get <code>pnt2</code> which is identical to <code>pnt1</code>:</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>pnt2 <span class="op">=</span> pnt2[<span class="op">~</span>pnt2.is_empty]  <span class="co">## Subset non-empty geometries</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>pnt2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="41">
<pre><code>0    POINT (0.25107 -0.16161)
7     POINT (0.03668 0.11738)
9    POINT (0.61645 -0.60380)
dtype: geometry</code></pre>
</div>
</div>
<p>This second approach will return features that partly intersect with <code>x.intersection(y)</code> but with modified geometries for spatially extensive features that cross the border of the subsetting object. The results are identical, but the implementation differs substantially.</p>
<p>Although the example above is rather contrived and provided for educational rather than applied purposes, and we encourage the reader to reproduce the results to deepen your understanding for handling geographic vector objects in R, it raises an important question: which implementation to use? Generally, more concise implementations should be favored, meaning the first approach above. We will return to the question of choosing between different implementations of the same technique or algorithm in Chapter 11.</p>
</section>
<section id="sec-geometry-unions" class="level3" data-number="4.3.7">
<h3 data-number="4.3.7" class="anchored" data-anchor-id="sec-geometry-unions"><span class="header-section-number">4.3.7</span> Geometry unions</h3>
<p>As we saw in <a href="02-attribute-operations.html#sec-vector-attribute-aggregation"><span>Section&nbsp;2.3.2</span></a>, spatial aggregation can silently dissolve the geometries of touching polygons in the same group. This is demonstrated in the code chunk below in which 49 <code>us_states</code> are aggregated into 4 regions using the <code>.dissolve</code> method:</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>regions <span class="op">=</span> us_states.dissolve(by<span class="op">=</span><span class="st">'REGION'</span>, aggfunc<span class="op">=</span><span class="st">'sum'</span>).reset_index()</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>regions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/usr/local/lib/python3.11/site-packages/geopandas/geodataframe.py:1676: FutureWarning: The default value of numeric_only in DataFrameGroupBy.sum is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.
  aggregated_data = data.groupby(**groupby_kwargs).agg(aggfunc)</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="42">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">REGION</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">AREA</th>
<th data-quarto-table-cell-role="th">total_pop_10</th>
<th data-quarto-table-cell-role="th">total_pop_15</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>Midwest</td>
<td>MULTIPOLYGON (((-89.10077 36.94...</td>
<td>1.984047e+06</td>
<td>66514091.0</td>
<td>67546398.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>Norteast</td>
<td>MULTIPOLYGON (((-75.61724 39.83...</td>
<td>4.357609e+05</td>
<td>54909218.0</td>
<td>55989520.0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>South</td>
<td>MULTIPOLYGON (((-81.38550 30.27...</td>
<td>2.314087e+06</td>
<td>112072990.0</td>
<td>118575377.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>West</td>
<td>MULTIPOLYGON (((-118.36998 32.8...</td>
<td>3.073145e+06</td>
<td>68444193.0</td>
<td>72264052.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The result is shown in <a href="#fig-dissolve">Figure&nbsp;<span>4.15</span></a>:</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">9</span>, <span class="fl">2.5</span>))</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>us_states.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], edgecolor<span class="op">=</span><span class="st">'black'</span>, column<span class="op">=</span><span class="st">'total_pop_15'</span>, legend<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'PuRd'</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>regions.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], edgecolor<span class="op">=</span><span class="st">'black'</span>, column<span class="op">=</span><span class="st">'total_pop_15'</span>, legend<span class="op">=</span><span class="va">True</span>, cmap<span class="op">=</span><span class="st">'PuRd'</span>)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'State'</span>)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Region'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-dissolve" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-dissolve-output-1.png" width="709" height="218" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.15: Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.</figcaption>
</figure>
</div>
</div>
</div>
<p>What is going on in terms of the geometries? Behind the scenes, <code>.dissolve</code> combines the geometries and dissolve the boundaries between them using the <a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.unary_union.html#geopandas.GeoSeries.unary_union"><code>.unary_union</code></a> method per group. This is demonstrated in the code chunk below which creates a united western US using the standalone <code>unary_union</code> operation:</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>us_west <span class="op">=</span> us_states[us_states[<span class="st">'REGION'</span>] <span class="op">==</span> <span class="st">'West'</span>]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>us_west_union <span class="op">=</span> us_west.geometry.unary_union</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that the result is a <code>shapely</code> geometry, as the individual attributes are “lost” as part of dissolving. The result is shown in <a href="#fig-dissolve2">Figure&nbsp;<span>4.16</span></a>.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>us_west_union</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<div id="fig-dissolve2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-dissolve2-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.16: Western US</figcaption>
</figure>
</div>
</div>
</div>
<p>To dissolve two (or more) groups of a <code>GeoDataFrame</code> into one geometry, we can either use a combined condition:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> (us_states[<span class="st">'REGION'</span>] <span class="op">==</span> <span class="st">'West'</span>) <span class="op">|</span> (us_states[<span class="st">'NAME'</span>] <span class="op">==</span> <span class="st">'Texas'</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>texas_union <span class="op">=</span> us_states[sel]</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>texas_union <span class="op">=</span> texas_union.geometry.unary_union</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>or concatenate the two separate subsets:</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>us_west <span class="op">=</span> us_states[us_states[<span class="st">'REGION'</span>] <span class="op">==</span> <span class="st">'West'</span>]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>texas <span class="op">=</span> us_states[us_states[<span class="st">'NAME'</span>] <span class="op">==</span> <span class="st">'Texas'</span>]</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>texas_union <span class="op">=</span> pd.concat([us_west, texas]).unary_union</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and then dissove using <code>.unary_union</code>. The result is identical in both cases, shown in <a href="#fig-dissolve3">Figure&nbsp;<span>4.17</span></a>.</p>
<div class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>texas_union</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<div id="fig-dissolve3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-dissolve3-output-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.17: Western US and Texas</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-type-transformations" class="level3" data-number="4.3.8">
<h3 data-number="4.3.8" class="anchored" data-anchor-id="sec-type-transformations"><span class="header-section-number">4.3.8</span> Type transformations</h3>
<p>Transformation of geometries, from one type to another, also known as “geometry casting”, is often required to facilitate spatial analysis. The <code>shapely</code> package can be used for geometry casting. The exact expression(s) depend on the specific transformation we are interested in. In general, you need to figure out the required input of the respective construstor function according to the “destination” geometry (e.g., <code>shapely.LineString</code>, etc.), then reshape the input of the “source” geometry into the right form to be passed to that function.</p>
<p>Let’s create a <code>"MultiPoint"</code> to illustrate how geometry casting works on <code>shapely</code> geometry objects:</p>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>multipoint <span class="op">=</span> shapely.MultiPoint([(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">3</span>,<span class="dv">3</span>), (<span class="dv">5</span>,<span class="dv">1</span>)])</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>multipoint</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="49">
<p><img src="04-geometry-operations_files/figure-html/cell-50-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>A <code>"LineString"</code> can be created using <code>shapely.LineString</code> from a <code>list</code> of points. Consequently, a <code>"MultiPoint"</code> can be converted to a <code>"LineString"</code> by extracting the individual points into a <code>list</code>, then passing them to <code>shapely.LineString</code>:</p>
<div class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>linestring <span class="op">=</span> shapely.LineString(<span class="bu">list</span>(multipoint.geoms))</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>linestring</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<p><img src="04-geometry-operations_files/figure-html/cell-51-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>A <code>"Polygon"</code> can also be created using function <code>shapely.Polygon</code>, which acceps a sequence of point coordinates. In principle, the last coordinate must be equal to the first, in order to form a closed shape. However, <code>shapely.Polygon</code> is able to complete the last coordinate automatically. Therefore:</p>
<div class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>polygon <span class="op">=</span> shapely.Polygon([[p.x, p.y] <span class="cf">for</span> p <span class="kw">in</span> multipoint.geoms])</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>polygon</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<p><img src="04-geometry-operations_files/figure-html/cell-52-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>The source <code>"MultiPoint"</code> geometry, and the derived <code>"LineString"</code> and <code>"Polygon"</code> geometries are shown in <a href="#fig-casting1">Figure&nbsp;<span>4.18</span></a>. Note that we convert the <code>shapely</code> geometries to <code>GeoSeries</code> for easier multi-panel plotting:</p>
<div class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries(multipoint).plot(ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries(linestring).plot(ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries(polygon).plot(ax<span class="op">=</span>axes[<span class="dv">2</span>])</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">"MultiPoint"</span>)</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">"LineString"</span>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">"Polygon"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-casting1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-casting1-output-1.png" width="632" height="149" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.18: Examples of linestring and polygon casted from a multipoint geometry.</figcaption>
</figure>
</div>
</div>
</div>
<p>Conversion from <code>"MultiPoint"</code> to <code>"LineString"</code> is a common operation that creates a line object from ordered point observations, such as GPS measurements or geotagged media. This allows spatial operations such as the length of the path traveled. Conversion from <code>"MultiPoint"</code> or <code>"LineString"</code> to <code>"Polygon"</code> is often used to calculate an area, for example from the set of GPS measurements taken around a lake or from the corners of a building lot.</p>
<p>Our <code>"LineString"</code> geometry can be converted bact to a <code>"MultiPoint"</code> geometry by passing its coordinates directly to <code>shapely.MultiPoint</code>:</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 'LineString' -&gt; 'MultiPoint'</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>shapely.MultiPoint(linestring.coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<p><img src="04-geometry-operations_files/figure-html/cell-54-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>The <code>"Polygon"</code> (exterior) coordinates can be passed to <code>shapely.MultiPoint</code> as well:</p>
<div class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 'Polygon' -&gt; 'MultiPoint'</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>shapely.MultiPoint(polygon.exterior.coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<p><img src="04-geometry-operations_files/figure-html/cell-55-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Using these methods, we can transform between <code>"Point"</code>, <code>"LineString"</code>, and <code>"Polygon"</code> geometries, assuming there is a sufficient number of points (at least two to form a line, and at least three to form a polygon). When dealing with multi-part geometries, we can:</p>
<ul>
<li>Access single-part geometries (e.g., each <code>"Polygion"</code> in a <code>"MultiPolygon"</code> geometry) using <code>.geoms[i]</code>, where <code>i</code> is the index of the geometry</li>
<li>Combine single-part geometries into a multi-part geometry, by passing a <code>list</code> of the latter to the constructor function</li>
</ul>
<p>For example, here is how we combine two <code>"Polygon"</code> geometries into a <code>"MultiPolygon"</code>:</p>
<div class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>multipolygon <span class="op">=</span> shapely.MultiPolygon([polygon, polygon])</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>multipolygon</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<p><img src="04-geometry-operations_files/figure-html/cell-56-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>and here is how we can get back the <code>"Polygon"</code> parts:</p>
<div class="cell" data-execution_count="56">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>multipolygon.geoms[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="56">
<p><img src="04-geometry-operations_files/figure-html/cell-57-output-1.svg" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>multipolygon.geoms[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<p><img src="04-geometry-operations_files/figure-html/cell-58-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>However, dealing with multi-part geometries is easier with <strong>geopandas</strong>, since that way we can keep track of the associated attributes: duplicating them when going from multi-part to single-part (using <code>.explode</code>, see below), or collapsing them through aggregation when going from single-part to multi-part (using <code>.dissolve</code>, see <a href="#sec-geometry-unions"><span>Section&nbsp;4.3.7</span></a>).</p>
<p>Let’s apply another commonly used type transformation to demonstrate. As input, we will create a <code>"MultiLineString"</code> geometry composed of three lines:</p>
<div class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>l1 <span class="op">=</span> shapely.LineString([(<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">4</span>, <span class="dv">3</span>)])</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>l2 <span class="op">=</span> shapely.LineString([(<span class="dv">4</span>, <span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">1</span>)])</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>l3 <span class="op">=</span> shapely.LineString([(<span class="dv">2</span>, <span class="dv">2</span>), (<span class="dv">4</span>, <span class="dv">2</span>)])</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>ml <span class="op">=</span> shapely.MultiLineString([l1, l2, l3])</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>ml</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="58">
<p><img src="04-geometry-operations_files/figure-html/cell-59-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p>Let’s place it into a <code>GeoSeries</code>:</p>
<div class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>geom <span class="op">=</span> gpd.GeoSeries([ml])</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>geom</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="59">
<pre><code>0    MULTILINESTRING ((1.00000 5.000...
dtype: geometry</code></pre>
</div>
</div>
<p>and finally into a <code>GeoDataFrame</code> with an attribute called <code>"id"</code>:</p>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>dat <span class="op">=</span> gpd.GeoDataFrame(geometry<span class="op">=</span>geom, data<span class="op">=</span>pd.DataFrame({<span class="st">'id'</span>: [<span class="dv">1</span>]}))</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>dat</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="60">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>MULTILINESTRING ((1.00000 5.000...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>You can imagine it as a road or river network. The above layer <code>dat</code> has only one row that defines all the lines. This restricts the number of operations that can be done, for example it prevents adding names to each line segment or calculating lengths of single lines. Using <code>shapely</code> methods which we are already familiar with (see above), the individual single-part geometries (i.e., the “parts”) can be accessed through the <code>.geoms</code> property:</p>
<div class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(ml.geoms)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="61">
<pre><code>[&lt;LINESTRING (1 5, 4 3)&gt;, &lt;LINESTRING (4 4, 4 1)&gt;, &lt;LINESTRING (2 2, 4 2)&gt;]</code></pre>
</div>
</div>
<p>However, spoecifically for the “multi-part to single part” type transformation scenarios, there is also a method called <code>.explode</code>, which can convert an entire multi-part <code>GeoDataFrame</code> to a single-part one. The advantage is that the original attributes (such as <code>id</code>) are retained, so that we can keep track of the original multi-part geometry properties that each part came from. The <code>index_parts=True</code> argument also lets us keep track of the original multipart geometry indices, and part indices, named <code>level_0</code> and <code>level_1</code>, respectively:</p>
<div class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>dat1 <span class="op">=</span> dat.explode(index_parts<span class="op">=</span><span class="va">True</span>).reset_index()</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>dat1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="62">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">level_0</th>
<th data-quarto-table-cell-role="th">level_1</th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>LINESTRING (1.00000 5.00000, 4....</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>LINESTRING (4.00000 4.00000, 4....</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>LINESTRING (2.00000 2.00000, 4....</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>For example, here we see that all <code>"LineString"</code> geometries came from the same multi-part geometry (<code>level_0</code>=<code>0</code>), which had three parts (<code>level_1</code>=<code>0</code>,<code>1</code>,<code>2</code>).</p>
<p><a href="#fig-multilinestring-to-linestring">Figure&nbsp;<span>4.19</span></a> demonstrates the effect of <code>.explode</code> in converting a layer with multi-part geometries into a layer with single part geometries.</p>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>dat.plot(ax<span class="op">=</span>axes[<span class="dv">0</span>], column<span class="op">=</span><span class="st">'id'</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>dat1.plot(ax<span class="op">=</span>axes[<span class="dv">1</span>], column<span class="op">=</span><span class="st">'level_1'</span>)</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'MultiLineString</span><span class="ch">\n</span><span class="st">1 feature'</span>)</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'LineString</span><span class="ch">\n</span><span class="st">3 features'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-multilinestring-to-linestring" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-multilinestring-to-linestring-output-1.png" width="409" height="305" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.19: Transformation from a <code>"MultiLineString"</code> layer with one feature (left), to a <code>"LineString"</code> layer with three features (right) using <code>.explode</code></figcaption>
</figure>
</div>
</div>
</div>
<p>The opposite transformation, i.e., “single-part to multi-part”, is acheived using the <code>.dissolve</code> method (<a href="#sec-geometry-unions"><span>Section&nbsp;4.3.7</span></a>). For example, here is how we can get back to the <code>"MultiLineString"</code> geometry:</p>
<div class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>dat1.dissolve(by<span class="op">=</span><span class="st">'id'</span>).reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="64">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">id</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">level_0</th>
<th data-quarto-table-cell-role="th">level_1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>MULTILINESTRING ((1.00000 5.000...</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Here is another example, dissolving the <code>nz</code> north and south parts into <code>"MultiPolygon"</code> geometries:</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>nz_dis1 <span class="op">=</span> nz[[<span class="st">'Island'</span>, <span class="st">'Population'</span>, <span class="st">'geometry'</span>]] <span class="op">\</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>    .dissolve(by<span class="op">=</span><span class="st">'Island'</span>, aggfunc<span class="op">=</span><span class="st">'sum'</span>) <span class="op">\</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    .reset_index()</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>nz_dis1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Island</th>
<th data-quarto-table-cell-role="th">geometry</th>
<th data-quarto-table-cell-role="th">Population</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>North</td>
<td>MULTIPOLYGON (((1865558.829 546...</td>
<td>3671600.0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>South</td>
<td>MULTIPOLYGON (((1229729.735 479...</td>
<td>1115600.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Note that <code>.dissolve</code> not only combines single-part into multi-part geometries, but also dissolves any internal borders. So, in fact, the result may single-part (in case when all parts touch each other, unlike in <code>nz</code>). If, for some reason, we want to combine geometries into multi-part <em>without</em> dissolving, we can fall back to the <strong>pandas</strong> <code>.agg</code> method (custom table aggregation), supplemented with a <strong>shapely</strong> function specifying how exactly we want to transform each group of geometries into a new single geometry. In the following example, for instance, we choose to collect all <code>"Polygon"</code>, and <code>"MultiPolygon"</code> parts, into a single <code>"MultiPolygon"</code> geometry with many parts:</p>
<div class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>nz_dis2 <span class="op">=</span> nz <span class="op">\</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    .groupby(<span class="st">'Island'</span>) <span class="op">\</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    .agg({</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Population'</span>: <span class="st">'sum'</span>,</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'geometry'</span>: <span class="kw">lambda</span> x: shapely.MultiPolygon(x.explode().to_list())</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    }) <span class="op">\</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    .reset_index()</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>nz_dis2 <span class="op">=</span> gpd.GeoDataFrame(nz_dis2).set_geometry(<span class="st">'geometry'</span>).set_crs(nz.crs)</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>nz_dis2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="66">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Island</th>
<th data-quarto-table-cell-role="th">Population</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>North</td>
<td>3671600.0</td>
<td>MULTIPOLYGON (((1745493.196 600...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>South</td>
<td>1115600.0</td>
<td>MULTIPOLYGON (((1557042.169 531...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The difference between the last two results (with and without dissolving, respectively) is not evident in the printout: in both cases we got a layer with two features of type <code>"MultiPolygon"</code>. However, in the first case internal borders were dissolved, while in the second case they were not. This is illustrated in <a href="#fig-combine-geoms">Figure&nbsp;<span>4.20</span></a>:</p>
<div>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>nz_dis1.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)<span class="op">;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>nz_dis2.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-combine-geoms" class="cell quarto-layout-panel" data-execution_count="67">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-combine-geoms-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-combine-geoms-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-combine-geoms" width="306"></p>
<figcaption class="figure-caption">(a) Dissolving (using <code>.dissolve</code>)</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 50.0%;justify-content: center;">
<div id="fig-combine-geoms-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-combine-geoms-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-combine-geoms" width="306"></p>
<figcaption class="figure-caption">(b) Combining without dissolving (using <code>agg</code> with a custom function)</figcaption>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.20: Combining New Zealand geometries into one, for each island</figcaption><p></p>
</figure>
</div>
</div>
</section>
</section>
<section id="sec-geo-ras" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="sec-geo-ras"><span class="header-section-number">4.4</span> Geometric operations on raster data</h2>
<section id="geometric-intersections" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="geometric-intersections"><span class="header-section-number">4.4.1</span> Geometric intersections</h3>
<p>In <a href="03-spatial-operations.html#sec-spatial-subsetting-raster"><span>Section&nbsp;3.4.1</span></a> we have shown how to extract values from a raster overlaid by points or by a matching boolean mask. In case the area of interest is defined by any general raster B (possibly non-matching), to retrieve a spatial output, that is, a (smaller) subset of raster A, we can:</p>
<ul>
<li>Extract the bounding box polygon of B (hereby, <code>clip</code>)</li>
<li>Mask and crop A (hereby, <code>elev.tif</code>) using B (<a href="05-raster-vector.html#sec-raster-cropping"><span>Section&nbsp;5.3</span></a>)</li>
</ul>
<p>For example, suppose that we want to get a subset of the <code>elev.tif</code> raster using another, smaller, raster. For demonstration, let’s create (see <a href="01-spatial-data.html#sec-raster-from-scratch"><span>Section&nbsp;1.3.3</span></a>) that smaller raster, hereby named <code>clip</code>. We first create a <span class="math inline">\(3 \times 3\)</span> array of raster values:</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>clip <span class="op">=</span> np.array([<span class="dv">1</span>] <span class="op">*</span> <span class="dv">9</span>).reshape(<span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>clip</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="68">
<pre><code>array([[1, 1, 1],
       [1, 1, 1],
       [1, 1, 1]])</code></pre>
</div>
</div>
<p>Then, we define the transformation matrix, in such a way that <code>clip</code> intersects with <code>elev.tif</code> (<a href="#fig-raster-intersection">Figure&nbsp;<span>4.21</span></a>):</p>
<div class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>new_transform <span class="op">=</span> rasterio.transform.from_origin(</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    west<span class="op">=</span><span class="fl">0.9</span>, </span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    north<span class="op">=</span><span class="fl">0.45</span>, </span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    xsize<span class="op">=</span><span class="fl">0.3</span>, </span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    ysize<span class="op">=</span><span class="fl">0.3</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>new_transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="69">
<pre><code>Affine(0.3, 0.0, 0.9,
       0.0, -0.3, 0.45)</code></pre>
</div>
</div>
<p>Now, for subsetting, we will derive a <code>shapely</code> geometry representing the <code>clip</code> raster extent, using <code>rasterio.transform.array_bounds</code>:</p>
<div class="cell" data-execution_count="70">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>bbox <span class="op">=</span> rasterio.transform.array_bounds(</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    clip.shape[<span class="dv">1</span>], <span class="co"># columns</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    clip.shape[<span class="dv">0</span>], <span class="co"># rows</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    new_transform</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>bbox</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="70">
<pre><code>(0.9, -0.4499999999999999, 1.7999999999999998, 0.45)</code></pre>
</div>
</div>
<p>The four numeric values can be transformed into a rectangular <code>shapely</code> geometry using <code>shapely.box</code>:</p>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>bbox <span class="op">=</span> shapely.box(<span class="op">*</span>bbox)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>bbox</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="71">
<p><img src="04-geometry-operations_files/figure-html/cell-72-output-1.svg" class="img-fluid"></p>
</div>
</div>
<p><a href="#fig-raster-intersection">Figure&nbsp;<span>4.21</span></a> shows the alignment of <code>bbox</code> and <code>elev.tif</code>:</p>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src_elev, ax<span class="op">=</span>ax)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([bbox]).plot(color<span class="op">=</span><span class="st">'none'</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-intersection" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-intersection-output-1.png" width="433" height="369" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.21: The <code>elev.tif</code> raster, and the extent of another (smaller) raster <code>clip</code> which we use to subset it</figcaption>
</figure>
</div>
</div>
</div>
<p>From here on, subsetting can be done using masking and cropping, just like with any other vector layer, regardless whether it is rectangular or not. We elaborate on masking and cropping in <a href="05-raster-vector.html#sec-raster-cropping"><span>Section&nbsp;5.3</span></a> (check that section for details about <code>rasterio.mask.mask</code>), but for completeness let’s go through that last step:</p>
<div class="cell" data-execution_count="73">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>out_image, out_transform <span class="op">=</span> rasterio.mask.mask(</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    src_elev, </span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    [bbox], </span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    crop<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    all_touched<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    nodata<span class="op">=</span><span class="dv">0</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting subset array <code>out_image</code> contains all pixels intersecting with <code>clip</code> <em>pixels</em> (not necessarily with the centroids!). However, due to the <code>all_touched=True</code> argument, those pixels which intersect with <code>clip</code>, but their centroid does not, retain their original values (e.g., <code>17</code>, <code>23</code>) rather than turned into “No Data” (e.g., <code>0</code>):</p>
<div class="cell" data-execution_count="74">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>out_image</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="74">
<pre><code>array([[[17, 18],
        [23, 24]]], dtype=uint8)</code></pre>
</div>
</div>
<p>Therefore, in our case, subset <code>out_image</code> dimensions are <span class="math inline">\(2 \times 2\)</span> (<a href="#fig-raster-intersection2">Figure&nbsp;<span>4.22</span></a>):</p>
<div class="cell" data-execution_count="75">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(out_image, transform<span class="op">=</span>out_transform, ax<span class="op">=</span>ax)</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>gpd.GeoSeries([bbox]).plot(color<span class="op">=</span><span class="st">'none'</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-intersection2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-intersection2-output-1.png" width="433" height="314" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.22: The resulting subset of the <code>elev.tif</code> raster</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-extent-and-origin" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="sec-extent-and-origin"><span class="header-section-number">4.4.2</span> Extent and origin</h3>
<p>When merging or performing map algebra on rasters, their resolution, projection, origin and/or extent have to match. Otherwise, how should we add the values of one raster with a resolution of 0.2 decimal degrees to a second raster with a resolution of 1 decimal degree? The same problem arises when we would like to merge satellite imagery from different sensors with different projections and resolutions. We can deal with such mismatches by aligning the rasters. Typically, raster alignment is done through resampling—that way, it is guaranteed that the rasters match exactly (<a href="#sec-raster-resampling"><span>Section&nbsp;4.4.4</span></a>). However, sometimes it can be useful to modify raster placement and extent “manually”, by adding or removing rows and columns, or by modifying the origin, that is, shifting the raster. For example, it may be useful to add extra rows and columns to a raster prior to focal operations, so that it is easier to operate on the edges.</p>
<p>Let’s demostrate the first operation, raster padding. First, we will read the array with the <code>elev.tif</code> values:</p>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> src_elev.read(<span class="dv">1</span>)</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>r</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="76">
<pre><code>array([[ 1,  2,  3,  4,  5,  6],
       [ 7,  8,  9, 10, 11, 12],
       [13, 14, 15, 16, 17, 18],
       [19, 20, 21, 22, 23, 24],
       [25, 26, 27, 28, 29, 30],
       [31, 32, 33, 34, 35, 36]], dtype=uint8)</code></pre>
</div>
</div>
<p>To pad an <code>ndarray</code>, we can use the <code>np.pad</code> function. The function accepts an array, and a tuple of the form <code>((rows_top,rows_bottom),(columns_left, columns_right))</code>. Also, we can specify the value that’s being used for padding with <code>constant_values</code> (e.g., <code>18</code>). For example, here we pad <code>r</code> with one extra row and two extra columns, on both sides:</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>cols <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.pad(r, ((rows,rows),(cols,cols)), constant_values<span class="op">=</span><span class="dv">18</span>)</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="77">
<pre><code>array([[18, 18, 18, 18, 18, 18, 18, 18, 18, 18],
       [18, 18,  1,  2,  3,  4,  5,  6, 18, 18],
       [18, 18,  7,  8,  9, 10, 11, 12, 18, 18],
       [18, 18, 13, 14, 15, 16, 17, 18, 18, 18],
       [18, 18, 19, 20, 21, 22, 23, 24, 18, 18],
       [18, 18, 25, 26, 27, 28, 29, 30, 18, 18],
       [18, 18, 31, 32, 33, 34, 35, 36, 18, 18],
       [18, 18, 18, 18, 18, 18, 18, 18, 18, 18]], dtype=uint8)</code></pre>
</div>
</div>
<p>However, for <code>s</code> to be used in spatial operations, we also have to update its transformation matrix. Whenever we add extra columns on the left, or extra rows on top, the raster <em>origin</em> changes. To reflect that fact, we take to “original” origin and add the required multiple of pixel widths or heights (i.e., raster resolution).</p>
<p>Recall from <a href="01-spatial-data.html#sec-raster-from-scratch"><span>Section&nbsp;1.3.3</span></a>, here is the transformation matrix of <code>elev.tif</code>:</p>
<div class="cell" data-execution_count="78">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>src_elev.transform </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="78">
<pre><code>Affine(0.5, 0.0, -1.5,
       0.0, -0.5, 1.5)</code></pre>
</div>
</div>
<p>From the transformation matrix, we can extract the origin:</p>
<div class="cell" data-execution_count="79">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>xmin, ymax <span class="op">=</span> src_elev.transform[<span class="dv">2</span>], src_elev.transform[<span class="dv">5</span>]</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>xmin, ymax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="79">
<pre><code>(-1.5, 1.5)</code></pre>
</div>
</div>
<p>And the resolution:</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>dx, dy <span class="op">=</span> src_elev.transform[<span class="dv">0</span>], src_elev.transform[<span class="dv">4</span>]</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>dx, dy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="80">
<pre><code>(0.5, -0.5)</code></pre>
</div>
</div>
<p>Now we can actually update the origin:</p>
<div class="cell" data-execution_count="81">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>xmin_new <span class="op">=</span> xmin <span class="op">-</span> dx <span class="op">*</span> cols</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>ymax_new <span class="op">=</span> ymax <span class="op">-</span> dy <span class="op">*</span> rows</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>xmin_new, ymax_new</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="81">
<pre><code>(-2.5, 2.0)</code></pre>
</div>
</div>
<p>Let’s create the updated transformation matrix (<a href="01-spatial-data.html#sec-raster-from-scratch"><span>Section&nbsp;1.3.3</span></a>). Keep in mind that the meaning of the last two arguments is <code>xsize</code>, <code>ysize</code>, so we need to pass the absolute value of <code>dy</code> (since it is negative).</p>
<div class="cell" data-execution_count="82">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>new_transform <span class="op">=</span> rasterio.transform.from_origin(xmin_new, ymax_new, dx, <span class="bu">abs</span>(dy))</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>new_transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="82">
<pre><code>Affine(0.5, 0.0, -2.5,
       0.0, -0.5, 2.0)</code></pre>
</div>
</div>
<p><a href="#fig-raster-shift-origin">Figure&nbsp;<span>4.23</span></a> shows the padded raster, with the outline of the original one, demonstrating that the origin was shifted correctly:</p>
<div class="cell" data-execution_count="83">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(s, transform<span class="op">=</span>new_transform, cmap<span class="op">=</span><span class="st">'Greys'</span>, ax<span class="op">=</span>ax)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>elev_bbox <span class="op">=</span> gpd.GeoSeries(shapely.box(<span class="op">*</span>src_elev.bounds))</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>elev_bbox.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-shift-origin" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-shift-origin-output-1.png" width="433" height="344" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.23: The padded <code>elev.tif</code> raster, and the outline of the extent of the original (in red)</figcaption>
</figure>
</div>
</div>
</div>
<p>We can shift a raster origin not just when padding, but in any other use case just by changing its transformation matrix. The effect is that the raster id going to be shifted. This is rarely required in real-life scenarios, but it is useful for understanding the concept of <em>raster origin</em>. For example, let’s shift the origin of <code>elev.tif</code> by <code>(-0.25,0.25)</code>:</p>
<div class="cell" data-execution_count="84">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>xmin_new <span class="op">=</span> xmin <span class="op">-</span> <span class="fl">0.25</span>  <span class="co"># shift xmin to the left</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>ymax_new <span class="op">=</span> ymax <span class="op">+</span> <span class="fl">0.25</span>  <span class="co"># shift ymax upwards</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>xmin_new, ymax_new</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="84">
<pre><code>(-1.75, 1.75)</code></pre>
</div>
</div>
<p>To shift the origin in other directions change the two operators (<code>-</code>, <code>+</code>) accordingly.</p>
<p>Again, let’s create the updated transformation matrix:</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>new_transform <span class="op">=</span> rasterio.transform.from_origin(xmin_new, ymax_new, dx, <span class="bu">abs</span>(dy))</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>new_transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="85">
<pre><code>Affine(0.5, 0.0, -1.75,
       0.0, -0.5, 1.75)</code></pre>
</div>
</div>
<p><a href="#fig-raster-shift-origin2">Figure&nbsp;<span>4.24</span></a> shows the shifted raster and the outline of the original:</p>
<div class="cell" data-execution_count="86">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(r, transform<span class="op">=</span>new_transform, cmap<span class="op">=</span><span class="st">'Greys'</span>, ax<span class="op">=</span>ax)</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>elev_bbox.plot(color<span class="op">=</span><span class="st">'none'</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>, ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-shift-origin2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-shift-origin2-output-1.png" width="430" height="411" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.24: The <code>elev.tif</code> raster shifted by <code>(0.25,0.25)</code> and the extent of the original (in red)</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-raster-agg-disagg" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="sec-raster-agg-disagg"><span class="header-section-number">4.4.3</span> Aggregation and disaggregation</h3>
<p>Raster datasets vary based on their resolution, from high resolution datasets that enable individual trees to be seen, to low resolution datasets covering the whole Earth. Raster datasets can be transformed to either decrease (aggregate) or increase (disaggregate) their resolution for a number of reasons. Aggregation can reduce computational resource requirements of raster storage and subsequent steps, disaggregation can be used to match other datasets or to add detail. As an example, we here change the spatial resolution of <code>dem.tif</code> by a factor of 5 (Figure <a href="#fig-raster-aggregate">Figure&nbsp;<span>4.25</span></a>).</p>
<p>Raster aggregation is, in fact, a special case of raster resampling (see <a href="#sec-raster-resampling"><span>Section&nbsp;4.4.4</span></a>), where the target raster grid is aligned with the original raster, only with coarser pixels. Raster resampling, is the general case where the new grid is not necessarily an aggregation of the original one, but any other case as well (such as a rotated and/or shifted one, etc.).</p>
<p>To aggregate a raster using <code>rasterio</code>, we go through <a href="https://rasterio.readthedocs.io/en/stable/topics/resampling.html">two steps</a>:</p>
<ul>
<li>Reading the raster values (using <code>.read</code>) into an <code>out_shape</code> that is different from the original <code>.shape</code></li>
<li>Updating the <code>transform</code> according to the <code>out_shape</code></li>
</ul>
<p>Let’s demonstrate, using the <code>dem.tif</code> file. Note the shape of the raster, it has 117 rows and 117 columns:</p>
<div class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>src.read(<span class="dv">1</span>).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="87">
<pre><code>(117, 117)</code></pre>
</div>
</div>
<p>Also note the <code>transform</code>, which tells us that the raster resolution is 30.85 <span class="math inline">\(m\)</span>:</p>
<div class="cell" data-execution_count="88">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>src.transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="88">
<pre><code>Affine(30.849999999999604, 0.0, 794599.1076146346,
       0.0, -30.84999999999363, 8935384.324602526)</code></pre>
</div>
</div>
<p>Now, instead of reading the raster values the usual way, as in <code>src.read(1)</code>, we can specify <code>out_shape</code> to read the values into a different shape. Here, we calculate a new shape which is downscaled by a factor of <code>5</code>, i.e., the number of rows and columns is multiplied by <code>0.2</code>. We must truncate any “partial” rows and columns, e.g., using <code>int</code>. Each new pixel is now obtained, or “resampled”, from <span class="math inline">\(\sim 5 \times 5 = \sim 25\)</span> “old” raster values. We can choose the resampling method through the <code>resampling</code> parameter. Here we use <code>rasterio.enums.Resampling.average</code>, i.e., the new “large” pixel value is the average of all coinciding small pixels, which makes sense for our elevation data in <code>dem.tif</code>:</p>
<div class="cell" data-execution_count="89">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>factor <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> src.read(<span class="dv">1</span>,</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    out_shape<span class="op">=</span>(</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">int</span>(src.height <span class="op">*</span> factor),</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">int</span>(src.width <span class="op">*</span> factor)</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    resampling<span class="op">=</span>rasterio.enums.Resampling.average</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting array <code>r</code> has a smaller <code>.shape</code>, as shown below:</p>
<div class="cell" data-execution_count="90">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>r.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="90">
<pre><code>(23, 23)</code></pre>
</div>
</div>
<p>Other useful <a href="https://rasterio.readthedocs.io/en/stable/api/rasterio.enums.html#rasterio.enums.Resampling">options</a> include:</p>
<ul>
<li><code>rasterio.enums.Resampling.nearest</code>—Nearest neighbor resampling</li>
<li><code>rasterio.enums.Resampling.bilinear</code>—Bilinear resampling</li>
<li><code>rasterio.enums.Resampling.cubic</code>—Cubic resampling</li>
<li><code>rasterio.enums.Resampling.lanczos</code>—Lanczos windowed resampling</li>
<li><code>rasterio.enums.Resampling.mode</code>—Mode resampling (most common value)</li>
<li><code>rasterio.enums.Resampling.min</code>—Minimum resampling</li>
<li><code>rasterio.enums.Resampling.max</code>—Maximum resampling</li>
<li><code>rasterio.enums.Resampling.med</code>—Median resampling</li>
<li><code>rasterio.enums.Resampling.sum</code>—Median resampling</li>
</ul>
<p>See below (<a href="#sec-raster-resampling"><span>Section&nbsp;4.4.4</span></a>) for an explanation of these methods.</p>
<p>The second step is to update the <code>transform</code>, taking into account the change in raster shape, as follows:</p>
<div class="cell" data-execution_count="91">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>new_transform <span class="op">=</span> src.transform <span class="op">*</span> src.transform.scale(</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    (src.width <span class="op">/</span> r.shape[<span class="dv">1</span>]),</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    (src.height <span class="op">/</span> r.shape[<span class="dv">0</span>])</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>new_transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="91">
<pre><code>Affine(156.93260869565017, 0.0, 794599.1076146346,
       0.0, -156.9326086956198, 8935384.324602526)</code></pre>
</div>
</div>
<p>The original raster and the aggregated one, are shown in <a href="#fig-raster-aggregate">Figure&nbsp;<span>4.25</span></a>:</p>
<div class="cell" data-execution_count="92">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(r, transform<span class="op">=</span>new_transform, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Aggregated (average)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-aggregate" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-aggregate-output-1.png" width="680" height="332" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.25: Original raster (left), and aggregated raster (right).</figcaption>
</figure>
</div>
</div>
</div>
<p>In case we need to export the new raster, we need to update the metadata:</p>
<div class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>dst_kwargs <span class="op">=</span> src.meta.copy()</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>dst_kwargs.update({</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'transform'</span>: new_transform,</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'width'</span>: r.shape[<span class="dv">1</span>],</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'height'</span>: r.shape[<span class="dv">0</span>],</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>dst_kwargs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="93">
<pre><code>{'driver': 'GTiff',
 'dtype': 'float32',
 'nodata': nan,
 'width': 23,
 'height': 23,
 'count': 1,
 'crs': CRS.from_epsg(32717),
 'transform': Affine(156.93260869565017, 0.0, 794599.1076146346,
        0.0, -156.9326086956198, 8935384.324602526)}</code></pre>
</div>
</div>
<p>Then create a new file in writing mode, and write the values in <code>r</code> into that file (see <a href="07-read-write-plot.html#sec-data-output-raster"><span>Section&nbsp;7.8.2</span></a>):</p>
<div class="cell" data-execution_count="94">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'output/dem_agg5.tif'</span>, <span class="st">'w'</span>, <span class="op">**</span>dst_kwargs)</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>dst.write(r, <span class="dv">1</span>)</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>dst.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The opposite operastion, disaggregation, is when we increase the resolution of raster objects. Either of the supported resampling methods (see above) can be used. However, since we are not actually summarizing information but transferring the value of a large pixel into multiple small pixels, it makes sense to use either:</p>
<ul>
<li>Nearest neighbor resampling (<code>rasterio.enums.Resampling.nearest</code>), when want to keep the original values as-is, since when modifying them would be incorrect (such as in categorical rasters)</li>
<li>Smooting techniques, such as Bilinear resampling (<code>rasterio.enums.Resampling.bilinear</code>), when we would like the smaller pixels to reflect gradual change between the original values, e.g., when the disaggregated raster is used for visulalization purposes</li>
</ul>
<p>To disaggregate a raster, we go through the same workflow as for aggregation, only using a different factor, such as <code>factor=5</code> instead of <code>factor=0.2</code>, i.e., <em>increasing</em> the number of raster pixels instead of decreasing. In this example, we use bilinear interpolation to get a smoothed high-resolution raster:</p>
<div class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>factor <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>r2 <span class="op">=</span> src.read(<span class="dv">1</span>,</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    out_shape<span class="op">=</span>(</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">int</span>(src.height <span class="op">*</span> factor),</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">int</span>(src.width <span class="op">*</span> factor)</span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    resampling<span class="op">=</span>rasterio.enums.Resampling.bilinear</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is the size of the disaggregated raster:</p>
<div class="cell" data-execution_count="96">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>r2.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="96">
<pre><code>(585, 585)</code></pre>
</div>
</div>
<p>And here is the same expression as shown for aggregation, to calculate the new transform:</p>
<div class="cell" data-execution_count="97">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>new_transform2 <span class="op">=</span> src.transform <span class="op">*</span> src.transform.scale(</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    (src.width <span class="op">/</span> r2.shape[<span class="dv">1</span>]),</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    (src.height <span class="op">/</span> r2.shape[<span class="dv">0</span>])</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>new_transform2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="97">
<pre><code>Affine(6.169999999999921, 0.0, 794599.1076146346,
       0.0, -6.169999999998726, 8935384.324602526)</code></pre>
</div>
</div>
<p>A zoom-in on the top-left corner of the original raster and the disaggregated one, are shown in <a href="#fig-raster-disaggregate">Figure&nbsp;<span>4.26</span></a>:</p>
<div class="cell" data-execution_count="98">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">4</span>))</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src.read(<span class="dv">1</span>)[:<span class="dv">5</span>, :<span class="dv">5</span>], transform<span class="op">=</span>src.transform, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(r2[:<span class="dv">25</span>, :<span class="dv">25</span>], transform<span class="op">=</span>new_transform2, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'Disaggregated (bilinear)'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-raster-disaggregate" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-disaggregate-output-1.png" width="669" height="346" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4.26: Original raster (left), and disaggregated raster (right). The same top-left corner extent of both rasters is shown, to zoom-in and demonstrate the effect of bilinear interpolation.</figcaption>
</figure>
</div>
</div>
</div>
<p>Code to export the disaggregated raster would be identical to the one used above for the aggregated raster, so omit it to save space.</p>
</section>
<section id="sec-raster-resampling" class="level3" data-number="4.4.4">
<h3 data-number="4.4.4" class="anchored" data-anchor-id="sec-raster-resampling"><span class="header-section-number">4.4.4</span> Resampling</h3>
<p>The above methods of aggregation and disaggregation are only suitable when we want to change the resolution of our raster by the aggregation/disaggregation factor. However, what to do when we have two or more rasters with different resolutions and origins? This is the role of resampling—a process of computing values for new pixel locations. In short, this process takes the values of our original raster and recalculates new values for a target raster with custom resolution and origin (<a href="#fig-raster-resample">Figure&nbsp;<span>4.27</span></a>).</p>
<p>There are several methods for estimating values for a raster with different resolutions/origins (<a href="#fig-raster-resample">Figure&nbsp;<span>4.27</span></a>). The main resampling methods include:</p>
<ul>
<li>Nearest neighbor: assigns the value of the nearest cell of the original raster to the cell of the target one. This is a fast simple technique that is usually suitable for resampling categorical rasters.</li>
<li>Bilinear interpolation: assigns a weighted average of the four nearest cells from the original raster to the cell of the target one. This is the fastest method that is appropriate for continuous rasters.</li>
<li>Cubic interpolation: uses values of the 16 nearest cells of the original raster to determine the output cell value, applying third-order polynomial functions. Used for continuous rasters and results in a smoother surface compared to bilinear interpolation, but is computationally more demanding.</li>
<li>Cubic spline interpolation: also uses values of the 16 nearest cells of the original raster to determine the output cell value, but applies cubic splines (piecewise third-order polynomial functions). Used for continuous rasters.</li>
<li>Lanczos windowed sinc resampling: uses values of the 36 nearest cells of the original raster to determine the output cell value. Used for continuous rasters.</li>
<li>Additionally, we can use straightforward summary methods, taking into account all pixels that coincide with the target pixel, such as average (<a href="#fig-raster-aggregate">Figure&nbsp;<span>4.25</span></a>), minimum, maximum (<a href="#fig-raster-resample">Figure&nbsp;<span>4.27</span></a>), median, mode, and sum.</li>
</ul>
<p>The above explanation highlights that only nearest neighbor resampling is suitable for categorical rasters, while all remaining methods can be used (with different outcomes) for continuous rasters.</p>
<p>With <code>rasterio</code>, resampling can be done using function <code>rasterio.warp.reproject</code>. Note, again, that raster reprojection is not fundamentally different from resampling—the difference is just whether the target grid is in the same CRS as the origin (resampling) or in a different CRS (reprojection). In other words, reprojection is <em>resampling</em> into a grid that is in a different CRS. We will demonstrate reprojection using <code>rasterio.warp.reproject</code> later on (<a href="06-reproj.html#sec-reprojecting-raster-geometries"><span>Section&nbsp;6.9</span></a>).</p>
<p>The information required for <code>rasterio.warp.reproject</code>, whether we are resampling or reprojecting, is:</p>
<ul>
<li>The source and target <em>CRS</em>. These may be identical, when resampling, or different, when reprojecting.</li>
<li>The source and target <em>transform</em></li>
</ul>
<p>Also, <code>rasterio.warp.reproject</code> works with file connections, so it requires a connection to an output file in write (<code>'w'</code>) mode. This makes the function efficient for large rasters.</p>
<p>The target and destination CRS are straightforward to specify, depending on our choice. The source transform is also available, e.g., from the source file connection. The only complicated part is to figure out the <em>destination transform</em>. When resampling, the transform is typically derived from a <em>template</em> raster, such as an existing raster file that we would like our origin raster to match, or a numeric specification of our target grid (see below). Otherwise, when the exact grid is not of importance, we can simply aggregate or disaggregate our raster as shown above (<a href="#sec-raster-agg-disagg"><span>Section&nbsp;4.4.3</span></a>). (Note that when reprojecting, the target transform is not straightforward to figure out, therefore we use the <code>rasterio.warp.calculate_default_transform</code> function to calculate it, as will be shown in <a href="06-reproj.html#sec-reprojecting-raster-geometries"><span>Section&nbsp;6.9</span></a>.)</p>
<p>Let’s demonstrate resampling into a destination grid which is specified through numeric contraints, such as the extent and resolution:</p>
<div class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>xmin <span class="op">=</span> <span class="dv">794650</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>xmax <span class="op">=</span> <span class="dv">798250</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>ymin <span class="op">=</span> <span class="dv">8931750</span> </span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>ymax <span class="op">=</span> <span class="dv">8935350</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> <span class="dv">300</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The transform is a function of the origin and resolution, and can be created using the <code>rasterio.transform.from_origin</code> function as follows:</p>
<div class="cell" data-execution_count="100">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>dst_transform <span class="op">=</span> rasterio.transform.from_origin(west<span class="op">=</span>xmin, north<span class="op">=</span>ymax, xsize<span class="op">=</span>res, ysize<span class="op">=</span>res)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>dst_transform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="100">
<pre><code>Affine(300.0, 0.0, 794650.0,
       0.0, -300.0, 8935350.0)</code></pre>
</div>
</div>
<p>Again, note that in case we needed to resample into a grid specified by an existing “template” raster, we could skip this step and simply use read the transform from that file, as in <code>rasterio.open('template.tif').transform</code>.</p>
<p>Now we move on to creating the destination file connection. For that, we also have to know the raster dimensions. These can be derived from the extent and the resolution, as follows:</p>
<div class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="bu">int</span>((xmax <span class="op">-</span> xmin) <span class="op">/</span> res)</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="bu">int</span>((ymax <span class="op">-</span> ymin) <span class="op">/</span> res)</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>width, height</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="101">
<pre><code>(12, 12)</code></pre>
</div>
</div>
<p>Now we create the destination file connection. We are using the same metadata as the source file, except for the dimensions and the transform, which are going to be different and reflecting the resampling process:</p>
<div class="cell" data-execution_count="102">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>dst_kwargs <span class="op">=</span> src.meta.copy()</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>dst_kwargs.update({</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'transform'</span>: dst_transform,</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'width'</span>: width,</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'height'</span>: height</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'output/dem_resample_nearest.tif'</span>, <span class="st">'w'</span>, <span class="op">**</span>dst_kwargs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is how we reproject, using function <code>rasterio.warp.reproject</code>. The resampling method being used here is nearest neighbor resampling:</p>
<div class="cell" data-execution_count="103">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>rasterio.warp.reproject(</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    source<span class="op">=</span>rasterio.band(src, <span class="dv">1</span>),</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    destination<span class="op">=</span>rasterio.band(dst, <span class="dv">1</span>),</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    src_transform<span class="op">=</span>src.transform,</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    src_crs<span class="op">=</span>src.crs,</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    dst_transform<span class="op">=</span>dst_transform,</span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>    dst_crs<span class="op">=</span>src.crs,</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    resampling<span class="op">=</span>rasterio.enums.Resampling.nearest</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="103">
<pre><code>(Band(ds=&lt;open DatasetWriter name='output/dem_resample_nearest.tif' mode='w'&gt;, bidx=1, dtype='float32', shape=(12, 12)),
 Affine(300.0, 0.0, 794650.0,
        0.0, -300.0, 8935350.0))</code></pre>
</div>
</div>
<p>In the end, we close the file:</p>
<div class="cell" data-execution_count="104">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>dst.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is another code section to demontrate another resampling method, the maximum resampling, i.e., every new pixel gets the maximum value of all the original pixels it coincides with. Note that the transform is identical (<a href="#fig-raster-resample">Figure&nbsp;<span>4.27</span></a>), so we do not need to calculate it again:</p>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>dst <span class="op">=</span> rasterio.<span class="bu">open</span>(<span class="st">'output/dem_resample_maximum.tif'</span>, <span class="st">'w'</span>, <span class="op">**</span>dst_kwargs)</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>rasterio.warp.reproject(</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    source<span class="op">=</span>rasterio.band(src, <span class="dv">1</span>),</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    destination<span class="op">=</span>rasterio.band(dst, <span class="dv">1</span>),</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    src_transform<span class="op">=</span>src.transform,</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    src_crs<span class="op">=</span>src.crs,</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    dst_transform<span class="op">=</span>dst_transform,</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>    dst_crs<span class="op">=</span>src.crs,</span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>    resampling<span class="op">=</span>rasterio.enums.Resampling.<span class="bu">max</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>dst.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The original raster <code>dem.tif</code>, and the two resampling results <code>dem_resample_nearest.tif</code> and <code>dem_resample_maximum.tif</code>, are shown in <a href="#fig-raster-resample">Figure&nbsp;<span>4.27</span></a>:</p>
<div>
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>,<span class="dv">4</span>))</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(src, ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Nearest neighbor</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>,<span class="dv">4</span>))</span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(rasterio.<span class="bu">open</span>(<span class="st">'output/dem_resample_nearest.tif'</span>), ax<span class="op">=</span>ax)<span class="op">;</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Maximum</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">4</span>,<span class="dv">4</span>))</span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>rasterio.plot.show(rasterio.<span class="bu">open</span>(<span class="st">'output/dem_resample_maximum.tif'</span>), ax<span class="op">=</span>ax)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="fig-raster-resample" class="cell quarto-layout-panel" data-execution_count="106">
<figure class="figure">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.5%;justify-content: center;">
<div id="fig-raster-resample-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-resample-output-1.png" class="img-fluid figure-img" data-ref-parent="fig-raster-resample" width="379"></p>
<figcaption class="figure-caption">(a) Input</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.2%;justify-content: center;">
<div id="fig-raster-resample-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-resample-output-2.png" class="img-fluid figure-img" data-ref-parent="fig-raster-resample" width="376"></p>
<figcaption class="figure-caption">(b) Nearest neighbor</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-display quarto-layout-cell quarto-layout-cell-subref" style="flex-basis: 33.2%;justify-content: center;">
<div id="fig-raster-resample-3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-geometry-operations_files/figure-html/fig-raster-resample-output-3.png" class="img-fluid figure-img" data-ref-parent="fig-raster-resample" width="376"></p>
<figcaption class="figure-caption">(c) Maximum</figcaption>
</figure>
</div>
</div>
</div>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.27: Visual comparison of the original raster and two different resampling methods’</figcaption><p></p>
</figure>
</div>
</div>
</section>
</section>
<section id="exercises" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="exercises"><span class="header-section-number">4.5</span> Exercises</h2>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./03-spatial-operations.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatial data operations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-raster-vector.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Raster-vector interactions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>