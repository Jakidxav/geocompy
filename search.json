[
  {
    "objectID": "index.html#motivations",
    "href": "index.html#motivations",
    "title": "Geocomputation with Python",
    "section": "\n1.1 Motivations",
    "text": "1.1 Motivations\nThis book, tentatively called Geocomputation with Python (‘geocompy’), is motivated by the need for an introductory yet rigorous and up-to-date resource on working with geographic data in Python that demonstrates basic data structures and describes code for handling vector and raster datasets in an integrated way. There are many resources on Python packages for geographic research and various applications but, to the best of our knowledge, no other resource brings together the following features into a single home:\n\nSmall introductory textbook focusses on doing basic operations well\nIntegration of vector and raster datasets in the same book, and within each section\nClear explanation of the code and exercises to maximise learning for newcomers\nProvision of lucid example datasets and meaningful operations to illustrate the applied nature of geographic research\n\nThe book aims to supplement other resources in the ecosystem, as highlighted by comparison with the book’s scope with existing and in-progress works:\n\n\npythongis.org (at an early stage of development) seeks to provide a general introduction to ‘GIS in Python’, with parts focussing on Python essentials, using Python with GIS, and case studies. Compared with pythongis.org, geocmpy has a relatively narrow scope (1) and a greater focus on raster-vecter interoperability\n\ngeographicdata.science is an ambitious project with chapters dedicated to advanced topics, with Chapter 4 on Spatial Weights getting into complex topics relatively early, for example. Geocompy would be shorter, simpler and more introductory, and cover raster and vector data with equal importance (1 to 4)"
  },
  {
    "objectID": "index.html#reproducing-this-book",
    "href": "index.html#reproducing-this-book",
    "title": "Geocomputation with Python",
    "section": "\n1.2 Reproducing this book",
    "text": "1.2 Reproducing this book\n\nAn important aspect of scientific research and ‘citizen science’ that is participatory is reproducibility of results. We aim to make this web version of the book as easy as possible. See the source code for details (work in progress)."
  },
  {
    "objectID": "02-spatial-data.html#introduction",
    "href": "02-spatial-data.html#introduction",
    "title": "2  Geographic data in Python",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nIn this chapter, we introduce the key Python libraries (and data structures) for working with the two major types of spatial data, namely:\n\nshapely and geopandas — for working with vector layers\nrasterio and xarray — for working with rasters\n\nAs we will see later on, shapely and geopandas are related:\n\nshapely is a “low-level” library for working with individual vector geometry objects\ngeopandas is a “high-level” library for working with geometry columns (GeoSeries objects), which internally contain shapely geometries, and vector layers (GeoDataFrame objects)\n\nWhile geopandas (including its shapely dependency), at present, comprises a ubiquitous comprehensive approach for working with vector layers in Python, this is not the case for rasters. Work with rasters in Python is much less unified. There are several alternative packages, each with its own advantages and disadvantages. We focus on the two most comprehensive and fundamental packages, namely:\n\nrasterio — a spatial-oriented package, focused on “simple” raster formats (such as GeoTIFF), representing a raster using a combination of a numpy array, and a metadata object (dict) specifying the spatial referencing of the array\nxarray — A general-purpose package for working with labeled arrays, thus advantageous for processing “complex” raster format (such as NetCDF), representing a raster using its own native classes, namely xarray.Dataset and xarray.DataArray"
  },
  {
    "objectID": "02-spatial-data.html#vector-data",
    "href": "02-spatial-data.html#vector-data",
    "title": "2  Geographic data in Python",
    "section": "2.2 Vector data",
    "text": "2.2 Vector data\n\n2.2.1 Introduction\nWhen introducing the packages for working with vector layers in Python, we are going to go from the complex class (vector layer), through the intermediate (geometry column), to the simple (geometry). As we will see, the three classes are hierarchical, meaning that the complex encompasses the simple:\n\nA vector layer (class GeoDataFrame) contains a geometry column (class GeoSeries) as one of the columns\nA geometry column (class GeoSeries) is composed of individual geometries (class shapely)\n\nThe first two classes (GeoDataFrame and GeoSeries) are defined in package geopandas. The third class is defined in package shapely, which deals with individual geometries, and comprises on of the dependencies of the geopandas package.\n\n\n2.2.2 Vector layers\nThe typical data structure for vector data is a vector layer. There are several methods to work with vector layers in Python, ranging from low-level (e.g., fiona) to high-level (geopandas). In this book, we focus on geopandas.\nBefore we begin, we need to import the geopandas package, conventionally as gpd:\n\nimport geopandas as gpd\n\nWe will also limit the maximum number of printed rows to four, to save space, using the \"display.max_rows\" option of pandas:\n\nimport pandas as pd\npd.set_option(\"display.max_rows\", 4)\n\nMost often, we import an existing vector layer from a file, such as a Shapefile or a GeoPackage file.\n\ndat = gpd.read_file(\"data/ne_110m_admin_0_countries.shp\")\n\nThe result is a GeoDataFrame:\n\ntype(dat)\n\ngeopandas.geodataframe.GeoDataFrame\n\n\nThe GeoDataFrame class is an extension of the DataFrame class. Thus, we can treat a vector layer as a table and process it using the ordinary, i.e., non-spatial, pandas methods. For example, the following expression creates a subset with just the country name and the geometry (see below):\n\ndat = dat[[\"SOVEREIGNT\", \"geometry\"]]\ndat\n\n\n\n\n  \n    \n      \n      SOVEREIGNT\n      geometry\n    \n  \n  \n    \n      0\n      Fiji\n      MULTIPOLYGON (((180.00000 -16.06713, 180.00000...\n    \n    \n      1\n      United Republic of Tanzania\n      POLYGON ((33.90371 -0.95000, 34.07262 -1.05982...\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      175\n      Trinidad and Tobago\n      POLYGON ((-61.68000 10.76000, -61.10500 10.890...\n    \n    \n      176\n      South Sudan\n      POLYGON ((30.83385 3.50917, 29.95350 4.17370, ...\n    \n  \n\n177 rows × 2 columns\n\n\n\nThe following expression creates a subset based on a condition, including just \"Egypt\":\n\ndat[dat[\"SOVEREIGNT\"] == \"Egypt\"]\n\n\n\n\n  \n    \n      \n      SOVEREIGNT\n      geometry\n    \n  \n  \n    \n      163\n      Egypt\n      POLYGON ((36.86623 22.00000, 32.90000 22.00000...\n    \n  \n\n\n\n\nFinally, to get a sense of the spatial component of the vector layer, it can be plotted using the .plot method, as follows:\n\ndat.plot()\n\n<AxesSubplot:>\n\n\n\n\n\n\n\n2.2.3 Geometry columns\nOne of the columns in a GeoDataFrame is a geometry column, of class GeoSeries. The geometry column contains the geometric part of the vector layer, e.g., the POLYGON or MULTIPOLYGON geometries of the 177 countries in dat:\n\ndat[\"geometry\"]\n\n0      MULTIPOLYGON (((180.00000 -16.06713, 180.00000...\n1      POLYGON ((33.90371 -0.95000, 34.07262 -1.05982...\n                             ...                        \n175    POLYGON ((-61.68000 10.76000, -61.10500 10.890...\n176    POLYGON ((30.83385 3.50917, 29.95350 4.17370, ...\nName: geometry, Length: 177, dtype: geometry\n\n\nThe geometry column also contains the spatial reference information, if any (see below).\nMany of the spatial operators, such as calculating the centroid, buffer, or bounding box of each feature, in fact involve just the geometry. Therefore, for example, the following expressions give exactly the same result, a GeoSeries with country bounding boxes:\n\ndat.bounds\n\n\n\n\n  \n    \n      \n      minx\n      miny\n      maxx\n      maxy\n    \n  \n  \n    \n      0\n      -180.000000\n      -18.287990\n      180.000000\n      -16.020882\n    \n    \n      1\n      29.339998\n      -11.720938\n      40.316590\n      -0.950000\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      175\n      -61.950000\n      10.000000\n      -60.895000\n      10.890000\n    \n    \n      176\n      23.886980\n      3.509172\n      35.298007\n      12.248008\n    \n  \n\n177 rows × 4 columns\n\n\n\n\ndat[\"geometry\"].bounds\n\n\n\n\n  \n    \n      \n      minx\n      miny\n      maxx\n      maxy\n    \n  \n  \n    \n      0\n      -180.000000\n      -18.287990\n      180.000000\n      -16.020882\n    \n    \n      1\n      29.339998\n      -11.720938\n      40.316590\n      -0.950000\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      175\n      -61.950000\n      10.000000\n      -60.895000\n      10.890000\n    \n    \n      176\n      23.886980\n      3.509172\n      35.298007\n      12.248008\n    \n  \n\n177 rows × 4 columns\n\n\n\nAnother useful property of the geometry column is the geometry type (see below). Note that the types of geometries contained in a geometry column (and, thus, a vector layer) are not necessarily the same. Accordingly, the .type property returns a Series (of type string), rather than a single value:\n\ndat[\"geometry\"].type\n\n0      MultiPolygon\n1           Polygon\n           ...     \n175         Polygon\n176         Polygon\nLength: 177, dtype: object\n\n\nTo summarize the occurrence of different geometry types in a geometry column, we can use the pandas method called value_counts:\n\ndat[\"geometry\"].type.value_counts()\n\nPolygon         148\nMultiPolygon     29\ndtype: int64\n\n\nIn this case, we see that the dat layer contains Polygon and MultiPolygon geometries.\n\n\n2.2.4 Geometries\nEach element in the geometry column is a geometry object, of class shapely. For example, here is one specific geometry selected by implicit index (that of Canada):\n\ndat[\"geometry\"].iloc[3]\n\n\n\n\nand here is a specific geometry selected based on the \"SOVEREIGNT\" attribute:\n\ndat[dat[\"SOVEREIGNT\"] == \"Egypt\"][\"geometry\"].iloc[0]\n\n\n\n\nThe shapely package is compatible with the Simple Features standard. Accordingly, seven types of geometries are supported. The following section demonstrates creating a shapely geometry of each type, using a string in the WKT format as input. First, we need to import the shapely.wkt module:\n\nimport shapely.wkt as wkt\n\nThen, we use the wkt.loads (stands for “load a WKT string”) to transform a WKT string to a shapely geometry object. Here is an example of a POINT geometry:\n\npoint = wkt.loads(\"POINT (5 2)\")\npoint\n\n\n\n\nHere is an example of a MULTIPOINT geometry:\n\nmultipoint = wkt.loads(\"MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\")\nmultipoint\n\n\n\n\nHere is an example of a LINESTRING geometry:\n\nlinestring = wkt.loads(\"LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\")\nlinestring\n\n\n\n\nHere is an example of a MULTILINESTRING geometry:\n\nmultilinestring = wkt.loads(\"MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\")\nmultilinestring\n\n\n\n\nHere is an example of a POLYGON geometry:\n\npolygon = wkt.loads(\"POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\")\npolygon\n\n\n\n\nHere is an example of a MULTIPOLYGON geometry:\n\nmultipolygon = wkt.loads(\"MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\")\nmultipolygon\n\n\n\n\nAnd, finally, here is an example of a GEOMETRYCOLLECTION geometry:\n\ngeometrycollection = wkt.loads(\"GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\")\ngeometrycollection\n\n\n\n\nshapely geometries act as atomic units of vector data, as spatial operations on a geometry return a single new geometry. For example, the following expression calculates the difference between the buffered multipolygon (using distance of 0.1) and itself:\n\nmultipolygon.buffer(0.2).difference(multipolygon)\n\n\n\n\nInternally, many spatial operations on a geometry column (or a vector layer) are basically iterations where the operator is applied on all geometries, one by one, to return a new geometry column (or layer) with the combined results.\nAs demonstrated above, a shapely geometry object is automatically evaluated to a small image of the geometry (when using an interface capable of displaying it, such as a Jupyter Notebook). To print the WKT string instead, we can use the print function:\n\nprint(linestring)\n\nLINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n\n\nWe can determine the geometry type using the .geom_type property, which is a string:\n\nlinestring.geom_type\n\n'LineString'\n\n\nFinally, it is important to note that raw coordinates of shapely geometries are accessible through a combination of the .coords, .geoms, .exterior, and .interiors, properties (depending on the geometry type). These access methods are useful for when we need to develop our own spatial operators for specific tasks. For example, the following expression returns the coordinates of the polygon geometry exterior (note that the returned object is iterable, thus enclosed in a list to return all coordinates at once):\n\nlist(polygon.exterior.coords)\n\n[(1.0, 5.0), (2.0, 2.0), (4.0, 1.0), (4.0, 4.0), (1.0, 5.0)]"
  },
  {
    "objectID": "02-spatial-data.html#raster-data",
    "href": "02-spatial-data.html#raster-data",
    "title": "2  Geographic data in Python",
    "section": "2.3 Raster data",
    "text": "2.3 Raster data\n\n2.3.1 Introduction\nAs mentioned above, working with rasters in Python is less organized around one comprehensive package (such as the case for vector layers and geopandas). Instead, there are several packages providing alternative (subsets of methods) of working with raster data.\nThe two most notable approaches for working with rasters in Python are provided by the rasterio and xarray packages. As we will see shortly, they differ in their scope and underlying data models. Specifically, rasterio represents rasters as numpy arrays associated with a separate object holding the spatial metadata. The xarray package, however, represents rasters with the native DataArray object, which is an extension of numpy array designed to hold axis labels and attributes, in the same object, together with the array of raster values.\nBoth packages are not comprehensive in the same way as ***geopandas** is. For example, when working with **rasterio**, on the one hand, more packages may be needed to accomplish (commonly used) tasks such as zonal statistics (packagezonalstats) or calculating topographic indices (packagerichdem`). On the other hand, xarray was extended to accommodate spatial operators missing from the core package itself, with the rioxarray and xarray-spatial packages.\nIn the following two sections, we introduce the two well-established packages, rasterio and xarray, which form the basis for most raster functionality in Python. Using any of the add-on packages, or the extensions, should be straightforward, once the reader is familiar with the basics.\n\n\n2.3.2 Using rasterio\nTo work with the rasterio package, we first need to import it. We also import numpy, since (as we will see shortly), the underlying raster data are stored in numpy arrays. To effectively work with those we therefore expose all numpy functions. Finally, we import the show function from the rasterio.plot sub-module for quick visualization of rasters.\n\nimport numpy as np\nimport rasterio\nfrom rasterio.plot import show\n\nRasters are typically imported from existing files. When working with rasterio, “importing” a raster is actually a two-step process:\n\nFirst, we open a raster file “connection”, using rasterio.open\nSecond, we read raster values from the connection using the .read method\n\nThis kind of separation is analogous to basic Python functions for reading from files, such as open and .readline to read from a text file. The rationale is that we do not always want to read all information from the file into memory, which is particularly important as rasters size can be larger than RAM size. Accordingly, the second step (.read) is selective. For example, we may want to read just one raster band rather than reading all band.\nIn the first step, to create a file connection, we pass a file path to the rasterio.open function. For this example, we use a single-band raster representing global population density in 2020:\n\nsrc = rasterio.open(\"data/gpw_v4_population_density_rev11_2020_15_min.tif\")\n\nThe “connection” object contains the raster metadata, that is, all of the information other than the raster values. Let us examine it:\n\nsrc.meta\n\n{'driver': 'GTiff',\n 'dtype': 'float32',\n 'nodata': -3.4028230607370965e+38,\n 'width': 1440,\n 'height': 720,\n 'count': 1,\n 'crs': CRS.from_epsg(4326),\n 'transform': Affine(0.25, 0.0, -180.0,\n        0.0, -0.25, 89.99999999999991)}\n\n\nImportantly, we can see:\n\nThe raster data type (dtype)\nRaster dimensions (width, height, and count, i.e., number of layers)\nRaster Coordinate Reference System (crs)\nThe raster affine transformation matrix (transform)\n\nThe last item (i.e., transform) deserves a few more words. To position a raster in geographical space, in addition to the CRS we must specify the raster origin (\\(x_{min}\\), \\(y_{max}\\)) and resolution (\\(delta_{x}\\), \\(delta_{y}\\)). In the transform matrix notation, these data items are stored as follows:\nAffine(delta_x, 0.0, x_min,\n       0.0, delta_y, y_max)\nNote that, by convention, raster y-axis origin is set to the maximum value (\\(y_{max}\\)) rather than the minimum, and, accordingly, the y-axis resolution (\\(delta_{y}\\)) is negative.\nTo get a first impression of the raster values, we can “plot” the file connection object as follows:\n\nshow(src)\n\n\n\n\n<AxesSubplot:>\n\n\nThis plot is not very informative due to the extreme range of raster values. We will see how to deal with this next, when reading the raster values.\nThe .read method of a raster file connection object is used to read the last but not least piece of information: the raster values. Importantly, we can read:\n\nA particular layer, passing a numeric index (as in .read(1))\nA subset of layers, passing a list of indices (as in .read([1,2]))\nAll layers (as in .read())\n\nNote that the layer indices start from 1 contrary to the Python convention of the first index being 0.\nThe resulting object is a numpy array, with either two or three dimensions:\n\nThree dimensions, when reading all layers or more than one layer (e.g., .read() or .read([1,2])). In such case, the dimensions pattern is (layers, rows, columns)\nTwo dimensions, when reading one specific layer (e.g., .read(1))\n\nFor example, let us read the first (and only) layer from our raster:\n\ns = src.read(1)\ns\n\narray([[-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       ...,\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38]], dtype=float32)\n\n\n\nshow(s)\n\n\n\n\n<AxesSubplot:>\n\n\n\nshow(np.log10(s))\n\n/tmp/ipykernel_208/534335260.py:1: RuntimeWarning: divide by zero encountered in log10\n  show(np.log10(s))\n/tmp/ipykernel_208/534335260.py:1: RuntimeWarning: invalid value encountered in log10\n  show(np.log10(s))\n\n\n\n\n\n<AxesSubplot:>\n\n\n\nmsk = src.read_masks(1)\nmsk\n\narray([[0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       ...,\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0]], dtype=uint8)\n\n\n\ns[msk == 0] = np.nan\n\n\nshow(s)\n\n\n\n\n<AxesSubplot:>\n\n\n\n\n2.3.3 Using xarray\n…\n\nimport xarray as xr\n\nReading:\n\nx = xr.open_dataset(\"data/air.2x2.250.mon.anom.comb.nc\")\nx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.Dataset>\nDimensions:  (lat: 90, lon: 180, time: 1692)\nCoordinates:\n  * lat      (lat) float32 89.0 87.0 85.0 83.0 81.0 ... -83.0 -85.0 -87.0 -89.0\n  * lon      (lon) float32 1.0 3.0 5.0 7.0 9.0 ... 351.0 353.0 355.0 357.0 359.0\n  * time     (time) datetime64[ns] 1880-01-01 1880-02-01 ... 2020-12-01\nData variables:\n    air      (time, lat, lon) float32 ...\nAttributes:\n    title:          GISS Surface Temperature Analysis (GISTEMP): 250km smooth...\n    platform:       Analysis\n    Source:         http://data.giss.nasa.gov/gistemp/ source and http://data...\n    Documentation:  http://www.esrl.noaa.gov/psd/data/gridded/data.gistemp.html\n    Conventions:    COARDS\n    history:        created at PSD Jun 2009 by CAS. Converted to chunked, def...\n    dataset_title:  GISS Surface Temperature Analysis\n    comments:       This is the 1200km smoothed combined land,ocean version o...\n    References:     https://www.psl.noaa.gov/data/gridded/data.gistemp.html\n    update_date:    01/2021\n    data_modified:  2021-01-29xarray.DatasetDimensions:lat: 90lon: 180time: 1692Coordinates: (3)lat(lat)float3289.0 87.0 85.0 ... -87.0 -89.0units :degrees_northlong_name :Latitudeactual_range :[ 89. -89.]axis :Ycoordinate_defines :centerstandard_name :latitudearray([ 89.,  87.,  85.,  83.,  81.,  79.,  77.,  75.,  73.,  71.,  69.,  67.,\n        65.,  63.,  61.,  59.,  57.,  55.,  53.,  51.,  49.,  47.,  45.,  43.,\n        41.,  39.,  37.,  35.,  33.,  31.,  29.,  27.,  25.,  23.,  21.,  19.,\n        17.,  15.,  13.,  11.,   9.,   7.,   5.,   3.,   1.,  -1.,  -3.,  -5.,\n        -7.,  -9., -11., -13., -15., -17., -19., -21., -23., -25., -27., -29.,\n       -31., -33., -35., -37., -39., -41., -43., -45., -47., -49., -51., -53.,\n       -55., -57., -59., -61., -63., -65., -67., -69., -71., -73., -75., -77.,\n       -79., -81., -83., -85., -87., -89.], dtype=float32)lon(lon)float321.0 3.0 5.0 ... 355.0 357.0 359.0units :degrees_eastlong_name :Longitudeactual_range :[  1. 359.]axis :Xcoordinate_defines :centerstandard_name :longitudearray([  1.,   3.,   5.,   7.,   9.,  11.,  13.,  15.,  17.,  19.,  21.,  23.,\n        25.,  27.,  29.,  31.,  33.,  35.,  37.,  39.,  41.,  43.,  45.,  47.,\n        49.,  51.,  53.,  55.,  57.,  59.,  61.,  63.,  65.,  67.,  69.,  71.,\n        73.,  75.,  77.,  79.,  81.,  83.,  85.,  87.,  89.,  91.,  93.,  95.,\n        97.,  99., 101., 103., 105., 107., 109., 111., 113., 115., 117., 119.,\n       121., 123., 125., 127., 129., 131., 133., 135., 137., 139., 141., 143.,\n       145., 147., 149., 151., 153., 155., 157., 159., 161., 163., 165., 167.,\n       169., 171., 173., 175., 177., 179., 181., 183., 185., 187., 189., 191.,\n       193., 195., 197., 199., 201., 203., 205., 207., 209., 211., 213., 215.,\n       217., 219., 221., 223., 225., 227., 229., 231., 233., 235., 237., 239.,\n       241., 243., 245., 247., 249., 251., 253., 255., 257., 259., 261., 263.,\n       265., 267., 269., 271., 273., 275., 277., 279., 281., 283., 285., 287.,\n       289., 291., 293., 295., 297., 299., 301., 303., 305., 307., 309., 311.,\n       313., 315., 317., 319., 321., 323., 325., 327., 329., 331., 333., 335.,\n       337., 339., 341., 343., 345., 347., 349., 351., 353., 355., 357., 359.],\n      dtype=float32)time(time)datetime64[ns]1880-01-01 ... 2020-12-01long_name :Timedelta_t :0000-01-00 00:00:00avg_period :0000-01-00 00:00:00standard_name :timeaxis :Tactual_range :[29219. 80688.]array(['1880-01-01T00:00:00.000000000', '1880-02-01T00:00:00.000000000',\n       '1880-03-01T00:00:00.000000000', ..., '2020-10-01T00:00:00.000000000',\n       '2020-11-01T00:00:00.000000000', '2020-12-01T00:00:00.000000000'],\n      dtype='datetime64[ns]')Data variables: (1)air(time, lat, lon)float32...long_name :Monthly Average Temperature Anomaliesvalid_range :[-25.  25.]units :degCprecision :2var_desc :Air Temperature: 250km smoothing combineddataset :GISS Surface Temperature Analysis (GISTEMP)level_desc :Surfacestatistic :Anomalyparent_stat :Individual obscell_methods :time: anomaly (monthly from values)standard_name :air_temperature_anomalycomments :ERSST V5 used for SST (starting Oct 25 2017 at PSD) from previous ERSST v4actual_range :[-19.858845  19.016056][27410400 values with dtype=float32]Attributes: (11)title :GISS Surface Temperature Analysis (GISTEMP): 250km smoothing combined land/oceanplatform :AnalysisSource :http://data.giss.nasa.gov/gistemp/ source and http://data.giss.nasa.gov/pub/gistemp/ dataDocumentation :http://www.esrl.noaa.gov/psd/data/gridded/data.gistemp.htmlConventions :COARDShistory :created at PSD Jun 2009 by CAS. Converted to chunked, deflated non-packed NetCDF4 2014/06dataset_title :GISS Surface Temperature Analysiscomments :This is the 1200km smoothed combined land,ocean version of the dataset on a 2x2 grid. SST dataset used at NASA is now ERSST V5References :https://www.psl.noaa.gov/data/gridded/data.gistemp.htmlupdate_date :01/2021data_modified :2021-01-29\n\n\n\nx[\"air\"]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<xarray.DataArray 'air' (time: 1692, lat: 90, lon: 180)>\n[27410400 values with dtype=float32]\nCoordinates:\n  * lat      (lat) float32 89.0 87.0 85.0 83.0 81.0 ... -83.0 -85.0 -87.0 -89.0\n  * lon      (lon) float32 1.0 3.0 5.0 7.0 9.0 ... 351.0 353.0 355.0 357.0 359.0\n  * time     (time) datetime64[ns] 1880-01-01 1880-02-01 ... 2020-12-01\nAttributes:\n    long_name:      Monthly Average Temperature Anomalies\n    valid_range:    [-25.  25.]\n    units:          degC\n    precision:      2\n    var_desc:       Air Temperature: 250km smoothing combined\n    dataset:        GISS Surface Temperature Analysis (GISTEMP)\n    level_desc:     Surface\n    statistic:      Anomaly\n    parent_stat:    Individual obs\n    cell_methods:   time: anomaly (monthly from values)\n    standard_name:  air_temperature_anomaly\n    comments:       ERSST V5 used for SST (starting Oct 25 2017 at PSD) from ...\n    actual_range:   [-19.858845  19.016056]xarray.DataArray'air'time: 1692lat: 90lon: 180...[27410400 values with dtype=float32]Coordinates: (3)lat(lat)float3289.0 87.0 85.0 ... -87.0 -89.0units :degrees_northlong_name :Latitudeactual_range :[ 89. -89.]axis :Ycoordinate_defines :centerstandard_name :latitudearray([ 89.,  87.,  85.,  83.,  81.,  79.,  77.,  75.,  73.,  71.,  69.,  67.,\n        65.,  63.,  61.,  59.,  57.,  55.,  53.,  51.,  49.,  47.,  45.,  43.,\n        41.,  39.,  37.,  35.,  33.,  31.,  29.,  27.,  25.,  23.,  21.,  19.,\n        17.,  15.,  13.,  11.,   9.,   7.,   5.,   3.,   1.,  -1.,  -3.,  -5.,\n        -7.,  -9., -11., -13., -15., -17., -19., -21., -23., -25., -27., -29.,\n       -31., -33., -35., -37., -39., -41., -43., -45., -47., -49., -51., -53.,\n       -55., -57., -59., -61., -63., -65., -67., -69., -71., -73., -75., -77.,\n       -79., -81., -83., -85., -87., -89.], dtype=float32)lon(lon)float321.0 3.0 5.0 ... 355.0 357.0 359.0units :degrees_eastlong_name :Longitudeactual_range :[  1. 359.]axis :Xcoordinate_defines :centerstandard_name :longitudearray([  1.,   3.,   5.,   7.,   9.,  11.,  13.,  15.,  17.,  19.,  21.,  23.,\n        25.,  27.,  29.,  31.,  33.,  35.,  37.,  39.,  41.,  43.,  45.,  47.,\n        49.,  51.,  53.,  55.,  57.,  59.,  61.,  63.,  65.,  67.,  69.,  71.,\n        73.,  75.,  77.,  79.,  81.,  83.,  85.,  87.,  89.,  91.,  93.,  95.,\n        97.,  99., 101., 103., 105., 107., 109., 111., 113., 115., 117., 119.,\n       121., 123., 125., 127., 129., 131., 133., 135., 137., 139., 141., 143.,\n       145., 147., 149., 151., 153., 155., 157., 159., 161., 163., 165., 167.,\n       169., 171., 173., 175., 177., 179., 181., 183., 185., 187., 189., 191.,\n       193., 195., 197., 199., 201., 203., 205., 207., 209., 211., 213., 215.,\n       217., 219., 221., 223., 225., 227., 229., 231., 233., 235., 237., 239.,\n       241., 243., 245., 247., 249., 251., 253., 255., 257., 259., 261., 263.,\n       265., 267., 269., 271., 273., 275., 277., 279., 281., 283., 285., 287.,\n       289., 291., 293., 295., 297., 299., 301., 303., 305., 307., 309., 311.,\n       313., 315., 317., 319., 321., 323., 325., 327., 329., 331., 333., 335.,\n       337., 339., 341., 343., 345., 347., 349., 351., 353., 355., 357., 359.],\n      dtype=float32)time(time)datetime64[ns]1880-01-01 ... 2020-12-01long_name :Timedelta_t :0000-01-00 00:00:00avg_period :0000-01-00 00:00:00standard_name :timeaxis :Tactual_range :[29219. 80688.]array(['1880-01-01T00:00:00.000000000', '1880-02-01T00:00:00.000000000',\n       '1880-03-01T00:00:00.000000000', ..., '2020-10-01T00:00:00.000000000',\n       '2020-11-01T00:00:00.000000000', '2020-12-01T00:00:00.000000000'],\n      dtype='datetime64[ns]')Attributes: (13)long_name :Monthly Average Temperature Anomaliesvalid_range :[-25.  25.]units :degCprecision :2var_desc :Air Temperature: 250km smoothing combineddataset :GISS Surface Temperature Analysis (GISTEMP)level_desc :Surfacestatistic :Anomalyparent_stat :Individual obscell_methods :time: anomaly (monthly from values)standard_name :air_temperature_anomalycomments :ERSST V5 used for SST (starting Oct 25 2017 at PSD) from previous ERSST v4actual_range :[-19.858845  19.016056]\n\n\nPlot:\n\nx[\"air\"].plot()\n\n(array([6.8000000e+01, 9.3800000e+02, 1.4441000e+04, 1.4905200e+05,\n        5.3337010e+06, 1.4529931e+07, 3.9248800e+05, 4.3241000e+04,\n        4.2550000e+03, 2.5200000e+02]),\n array([-19.858845  , -15.9713545 , -12.083864  ,  -8.196375  ,\n         -4.3088846 ,  -0.42139435,   3.4660957 ,   7.3535857 ,\n         11.2410755 ,  15.128566  ,  19.016056  ], dtype=float32),\n <BarContainer object of 10 artists>)"
  },
  {
    "objectID": "02-spatial-data.html#coordinate-reference-systems",
    "href": "02-spatial-data.html#coordinate-reference-systems",
    "title": "2  Geographic data in Python",
    "section": "2.4 Coordinate Reference Systems",
    "text": "2.4 Coordinate Reference Systems\n\ndat.crs\n\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\nsrc.crs\n\nCRS.from_epsg(4326)"
  },
  {
    "objectID": "02-spatial-data.html#exercises",
    "href": "02-spatial-data.html#exercises",
    "title": "2  Geographic data in Python",
    "section": "2.5 Exercises",
    "text": "2.5 Exercises\n…"
  }
]