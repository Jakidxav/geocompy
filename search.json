[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Geocomputation with Python",
    "section": "",
    "text": "(is_on_ghactions = identical(Sys.getenv(\"GITHUB_ACTIONS\"), \"true\"))\n\n[1] TRUE\n\n(is_online = curl::has_internet())\n\n[1] TRUE\n\n(is_html = knitr::is_html_output())\n\n[1] TRUE\n\n\n\n1 Welcome"
  },
  {
    "objectID": "02-spatial-data.html#introduction",
    "href": "02-spatial-data.html#introduction",
    "title": "2  Geographic data in Python",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nIn this chapter, we introduce the key Python libraries (and data structures) for working with the two major types of spatial data, namely:\n\nshapely and geopandas—For working with vector layers\nrasterio and xarray—For working with rasters\n\nAs we will see later on, shapely and geopandas are related:\n\nshapely is a “low-level” library for working with individual vector geometry objects\ngeopandas is a “high-level” library for working with geometry columns (GeoSeries objects), which internally contain shapely geometries, and vector layers (GeoDataFrame objects)\n\nWhile geopandas (including its shapely dependency), at present, comprises a ubiquitous comprehensive approach for working with vector layers in Python, this is not the case for rasters. Work with rasters in Python is much less unified. There are several alternative packages, each with its own advantages and disadvantages. We focus on the two most comprehensive and fundamental, namely:\n\nrasterio—…\nxarray—…"
  },
  {
    "objectID": "02-spatial-data.html#vector-data",
    "href": "02-spatial-data.html#vector-data",
    "title": "2  Geographic data in Python",
    "section": "2.2 Vector data",
    "text": "2.2 Vector data\n\n2.2.1 Introduction\nWhen introducing the packages for working with vector layers in Python, we are going to go from the complex class (vector layer), through the intermediate (geometry column), to the simple (geometry). As we will see, the three classes are hierarchical, meaning that the complex encompasses the simple:\n\nA vector layer (class GeoDataFrame) contains a geometry column (class GeoSeries) as one of the columns\nA geometry column (class GeoSeries) is composed of individual geometries (class shapely)\n\nThe first two classes (GeoDataFrame and GeoSeries) are defined in package geopandas. The third class is defined in package shapely, which deals with individual geometries, and comprises on of the dependencies of the geopandas package.\n\n\n2.2.2 Vector layers\nThe typical data structure for vector data is a vector layer. There are several methods to work with vector layers in Python, ranging from low-level (e.g., fiona) to high-level (geopandas). In this book, we focus on geopandas.\nBefore we begin, we need to import the geopandas package, conventionally as gpd:\n\nimport geopandas as gpd\n\nWe will also limit the maximum number of printed rows to four, to save space, using the \"display.max_rows\" option of pandas:\n\nimport pandas as pd\npd.set_option(\"display.max_rows\", 4)\n\nMost often, we import an existing vector layer from a file, such as a Shapefile or a GeoPackage file.\n\ndat = gpd.read_file(\"data/ne_110m_admin_0_countries.shp\")\n\nThe result is a GeoDataFrame:\n\ntype(dat)\n\ngeopandas.geodataframe.GeoDataFrame\n\n\nThe GeoDataFrame class is an extension of the DataFrame class. Thus, we can treat a vector layer as a table and process it using the ordinary, i.e., non-spatial, pandas methods. For example, the following expression creates a subset with just the country name and the geometry (see below):\n\ndat = dat[[\"SOVEREIGNT\", \"geometry\"]]\ndat\n\n\n\n\n  \n    \n      \n      SOVEREIGNT\n      geometry\n    \n  \n  \n    \n      0\n      Fiji\n      MULTIPOLYGON (((180.00000 -16.06713, 180.00000...\n    \n    \n      1\n      United Republic of Tanzania\n      POLYGON ((33.90371 -0.95000, 34.07262 -1.05982...\n    \n    \n      ...\n      ...\n      ...\n    \n    \n      175\n      Trinidad and Tobago\n      POLYGON ((-61.68000 10.76000, -61.10500 10.890...\n    \n    \n      176\n      South Sudan\n      POLYGON ((30.83385 3.50917, 29.95350 4.17370, ...\n    \n  \n\n177 rows × 2 columns\n\n\n\nThe following expression creates a subset based on a condition, including just \"Egypt\":\n\ndat[dat[\"SOVEREIGNT\"] == \"Egypt\"]\n\n\n\n\n  \n    \n      \n      SOVEREIGNT\n      geometry\n    \n  \n  \n    \n      163\n      Egypt\n      POLYGON ((36.86623 22.00000, 32.90000 22.00000...\n    \n  \n\n\n\n\nFinally, to get a sense of the spatial component of the vector layer, it can be plotted using the .plot method, as follows:\n\ndat.plot()\n\n<AxesSubplot:>\n\n\n\n\n\n\n\n2.2.3 Geometry columns\nOne of the columns in a GeoDataFrame is a geometry column, of class GeoSeries. The geometry column contains the geometric part of the vector layer, e.g., the POLYGON or MULTIPOLYGON geometries of the 177 countries in dat:\n\ndat[\"geometry\"]\n\n0      MULTIPOLYGON (((180.00000 -16.06713, 180.00000...\n1      POLYGON ((33.90371 -0.95000, 34.07262 -1.05982...\n                             ...                        \n175    POLYGON ((-61.68000 10.76000, -61.10500 10.890...\n176    POLYGON ((30.83385 3.50917, 29.95350 4.17370, ...\nName: geometry, Length: 177, dtype: geometry\n\n\nThe geomtery column also contains the spatial reference information, if any (see below).\nMany of the spatial operators, such as calculating the centroid, buffer, or bounding box of each feature, in fact involve just the geometry. Therefore, for example, the following expressions give exactly the same result, a GeoSeries with country bounding boxes:\n\ndat.bounds\n\n\n\n\n  \n    \n      \n      minx\n      miny\n      maxx\n      maxy\n    \n  \n  \n    \n      0\n      -180.000000\n      -18.287990\n      180.000000\n      -16.020882\n    \n    \n      1\n      29.339998\n      -11.720938\n      40.316590\n      -0.950000\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      175\n      -61.950000\n      10.000000\n      -60.895000\n      10.890000\n    \n    \n      176\n      23.886980\n      3.509172\n      35.298007\n      12.248008\n    \n  \n\n177 rows × 4 columns\n\n\n\n\ndat[\"geometry\"].bounds\n\n\n\n\n  \n    \n      \n      minx\n      miny\n      maxx\n      maxy\n    \n  \n  \n    \n      0\n      -180.000000\n      -18.287990\n      180.000000\n      -16.020882\n    \n    \n      1\n      29.339998\n      -11.720938\n      40.316590\n      -0.950000\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      175\n      -61.950000\n      10.000000\n      -60.895000\n      10.890000\n    \n    \n      176\n      23.886980\n      3.509172\n      35.298007\n      12.248008\n    \n  \n\n177 rows × 4 columns\n\n\n\nAnother useful property of the geometry column is the geometry type (see below). Note that the types of geometries contained in a geometry column (and, thus, a vector layer) are not necessarily the same. Accordingly, the .type property returns a Series (of type string), rather than a single value:\n\ndat[\"geometry\"].type\n\n0      MultiPolygon\n1           Polygon\n           ...     \n175         Polygon\n176         Polygon\nLength: 177, dtype: object\n\n\nTo summarize the occurence of different geometry types in a geometry column, we can use the pandas method named value_counts:\n\ndat[\"geometry\"].type.value_counts()\n\nPolygon         148\nMultiPolygon     29\ndtype: int64\n\n\nIn this case, we see that the dat layer contains Polygon and MultiPolygon geometries.\n\n\n2.2.4 Geometries\nEach element in the geometry column is a geometry object, of class shapely. For example, here is one specific geometry selected by implicit index (that of Canada):\n\ndat[\"geometry\"].iloc[3]\n\n\n\n\nand here is a specific geometry selected based on the \"SOVEREIGNT\" attribute:\n\ndat[dat[\"SOVEREIGNT\"] == \"Egypt\"][\"geometry\"].iloc[0]\n\n\n\n\nThe shapely package is compatible with the Simple Features standard. Accoridngly, seven types of geometries are supported. The following section demonstrates creating a shapely geometry of each type, using a string in the WKT format as input. First, we need to import the shapely.wkt module:\n\nimport shapely.wkt as wkt\n\nThen, we use the wkt.loads (stands for “load a WKT string”) to transform a WKT string to a shapely geometry object. Here is an example of a POINT geometry:\n\npoint = wkt.loads(\"POINT (5 2)\")\npoint\n\n\n\n\nHere is an example of a MULTIPOINT geometry:\n\nmultipoint = wkt.loads(\"MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\")\nmultipoint\n\n\n\n\nHere is an example of a LINESTRING geometry:\n\nlinestring = wkt.loads(\"LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\")\nlinestring\n\n\n\n\nHere is an example of a MULTILINESTRING geometry:\n\nmultilinestring = wkt.loads(\"MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\")\nmultilinestring\n\n\n\n\nHere is an example of a POLYGON geometry:\n\npolygon = wkt.loads(\"POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\")\npolygon\n\n\n\n\nHere is an example of a MULTIPOLYGON geometry:\n\nmultipolygon = wkt.loads(\"MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\")\nmultipolygon\n\n\n\n\nAnd, finally, here is an example of a GEOMETRYCOLLECTION geometry:\n\ngeometrycollection = wkt.loads(\"GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\")\ngeometrycollection\n\n\n\n\nshapely geometries act as atomic units of vector data, as spatial operations on a geometry return a single new geometry. For example, the following expression calculates the difference between the buffered multipolygon (using distance of 0.1) and itself:\n\nmultipolygon.buffer(0.2).difference(multipolygon)\n\n\n\n\nInternally, many spatial operations on a geometry column (or a vector layer) are basically iterations where the operator is applied on all geometries, one by one, to return a new geometry column (or layer) with the combined results.\nAs demonstrated above, a shapely geometry object is automatically evaluated to a small image of the geometry (when using an interface capable of displaying it, such as a Jupyter Notebook). To print the WKT string instead, we can use the print function:\n\nprint(linestring)\n\nLINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n\n\nWe can determine the geometry type using the .geom_type property, which is a string:\n\nlinestring.geom_type\n\n'LineString'\n\n\nFinally, it is important to note that raw coordinates of shapely geometries are accessible through a combination of the .coords, .geoms, .exterior, and .interiors, properties (depending on the geometry type). These access methods are useful for when we need to develop our own spatial operators for specific tasks. For example, the following expression returns the coordinates of the polygon geometry exterior (note that the returned object is iterable, thus enclosed in a list to return all coordinates at once):\n\nlist(polygon.exterior.coords)\n\n[(1.0, 5.0), (2.0, 2.0), (4.0, 1.0), (4.0, 4.0), (1.0, 5.0)]"
  },
  {
    "objectID": "02-spatial-data.html#raster-data",
    "href": "02-spatial-data.html#raster-data",
    "title": "2  Geographic data in Python",
    "section": "2.3 Raster data",
    "text": "2.3 Raster data\n\n2.3.1 Introduction\nAs mentioned above, working with rasters in Python is less organized around one comprehensive package (such as the case for vector layers and geopandas). Instead, there are several packages providing alternative (subsets of methods) of working with raster data.\nThe two most notable approaches for working with rasters in Python are provided by the rasterio and xarray packages. As we will see shortly, they differ in their scope and underlying data models. Specifically, rasterio represents rasters as numpy arrays associated with a separate object holding the spatial metadata. The xarray package, however, represents rasters with the native DataArray object, which is an extension of numpy array designed to hold axis labels and attributes, in the same object together with the array of raster values.\nBoth packages are not comprehensive in the same way as geopandas is. For example, on the one hand, more packages may be needed to accomplish tasks such as zonal statistics (package zonalstats) or to calculate topographic indices (package richdem) which working with rasterio. On the other hand, xarray was extended to accomodate spatial operatiors, with the rioxarray and xarray-spatial packages.\nIn the following two sections, we introduce the core well-established packages rasterio and xarray, which form the basis for most raster functionality in Python. Using any of the add-on packages, or the extensions, should be straightforward, once the reader is familiar with the basics.\n\n\n2.3.2 Using rasterio\nImporting the rasterio package:\n\nimport numpy as np\nimport rasterio\nfrom rasterio.plot import show\n\nCreating a file connection:\n\nsrc = rasterio.open(\"data/gpw_v4_population_density_rev11_2020_15_min.tif\")\n\nExamining the metadata:\n\nsrc.meta\n\n{'driver': 'GTiff',\n 'dtype': 'float32',\n 'nodata': -3.4028230607370965e+38,\n 'width': 1440,\n 'height': 720,\n 'count': 1,\n 'crs': CRS.from_epsg(4326),\n 'transform': Affine(0.25, 0.0, -180.0,\n        0.0, -0.25, 89.99999999999991)}\n\n\nPlotting:\n\nshow(src)\n\n\n\n\n<AxesSubplot:>\n\n\nReading the 1st layer:\n\ns = src.read(1)\ns\n\narray([[-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       ...,\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38],\n       [-3.402823e+38, -3.402823e+38, -3.402823e+38, ..., -3.402823e+38,\n        -3.402823e+38, -3.402823e+38]], dtype=float32)\n\n\n\nshow(s)\n\n\n\n\n<AxesSubplot:>\n\n\n\nmsk = src.read_masks(1)\nmsk\n\narray([[0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       ...,\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0]], dtype=uint8)\n\n\n\ns[msk == 0] = np.nan\n\n\nshow(s)\n\n\n\n\n<AxesSubplot:>\n\n\n\n\n2.3.3 Using xarray\n…\n\nimport xarray as xr\n\nReading:\n\n# x = xr.open_dataset(\"data/air.2x2.250.mon.anom.comb.nc\")\n# x\n\n\n# x[\"air\"]\n\nPlot:\n\n# x[\"air\"].plot()"
  },
  {
    "objectID": "02-spatial-data.html#coordinate-reference-systems",
    "href": "02-spatial-data.html#coordinate-reference-systems",
    "title": "2  Geographic data in Python",
    "section": "2.4 Coordinate Reference Systems",
    "text": "2.4 Coordinate Reference Systems\n\ndat.crs\n\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\nsrc.crs\n\nCRS.from_epsg(4326)"
  },
  {
    "objectID": "02-spatial-data.html#exercises",
    "href": "02-spatial-data.html#exercises",
    "title": "2  Geographic data in Python",
    "section": "2.5 Exercises",
    "text": "2.5 Exercises\n…"
  }
]