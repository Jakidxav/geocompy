{
  "hash": "61b87f5b4e312f854353f27a1efa15ff",
  "result": {
    "markdown": "# Raster-vector interactions {#raster-vector}\n\n## Prerequisites\n\n\n\nLet's import the required packages:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport rasterio\nimport rasterio.mask\nfrom rasterio.plot import show\n```\n\n::: {.cell-output-stderr}\n```\n/home/michael/.local/lib/python3.8/site-packages/geopandas/_compat.py:111: UserWarning:\n\nThe Shapely GEOS version (3.10.2-CAPI-1.16.0) is incompatible with the GEOS version PyGEOS was compiled with (3.10.1-CAPI-1.16.0). Conversions between both will be slow.\n\n```\n:::\n:::\n\n\nand load the sample data:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsrc_srtm = rasterio.open(\"data/srtm.tif\")\nzion = gpd.read_file(\"data/zion.gpkg\")\nzion_points = gpd.read_file(\"data/zion_points.gpkg\")\n```\n:::\n\n\n## Introduction\n\n## Raster cropping\n\nMany geographic data projects involve integrating data from many different sources, such as remote sensing images (rasters) and administrative boundaries (vectors). Often the extent of input raster datasets is larger than the area of interest. In this case raster **cropping** and **masking** are useful for unifying the spatial extent of input data. Both operations reduce object memory use and associated computational resources for subsequent analysis steps, and may be a necessary preprocessing step before creating attractive maps involving raster data.\n\nWe will use two objects to illustrate raster cropping:\n\n* The `srtm.tif` raster representing elevation (meters above sea level) in south-western Utah\n* The `zion.gpkg` vector layer representing the Zion National Park\n\nBoth target and cropping objects must have the same projection. The following reprojects the vector layer `zion` into the CRS of the raster `src_srtm`:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nzion = zion.to_crs(src_srtm.crs)\n```\n:::\n\n\nTo mask the image, i.e., convert all pixels which do not intersect with the `zion` polygon to \"No Data\", we use the `rasterio.mask.mask` function as follows:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nout_image_mask, out_transform_mask = rasterio.mask.mask(\n    src_srtm, \n    zion[\"geometry\"], \n    crop=False, \n    nodata=9999\n)\n```\n:::\n\n\nNote that we need to specify a \"No Data\" value in agreement with the raster data type. Since `srtm.tif` is of type `uint16`, we choose `9999` (a positive integer that is guaranteed not to occur in the raster). \n\nThe result is the `out_image` array with the masked values: \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nout_image_mask\n```\n\n::: {.cell-output-display execution_count=6}\n```\narray([[[9999, 9999, 9999, ..., 9999, 9999, 9999],\n        [9999, 9999, 9999, ..., 9999, 9999, 9999],\n        [9999, 9999, 9999, ..., 9999, 9999, 9999],\n        ...,\n        [9999, 9999, 9999, ..., 9999, 9999, 9999],\n        [9999, 9999, 9999, ..., 9999, 9999, 9999],\n        [9999, 9999, 9999, ..., 9999, 9999, 9999]]], dtype=uint16)\n```\n:::\n:::\n\n\nand the new `out_transform`:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nout_transform_mask\n```\n\n::: {.cell-output-display execution_count=7}\n```\nAffine(0.0008333333332777796, 0.0, -113.23958321278403,\n       0.0, -0.0008333333332777843, 37.512916763165805)\n```\n:::\n:::\n\n\nNote that masking (without cropping!) does not modify the raster spatial configuration. Therefore, the new transform is identical to the original:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nsrc_srtm.transform\n```\n\n::: {.cell-output-display execution_count=8}\n```\nAffine(0.0008333333332777796, 0.0, -113.23958321278403,\n       0.0, -0.0008333333332777843, 37.512916763165805)\n```\n:::\n:::\n\n\nUnfortunately, the `out_image` and `out_transform` object do not contain any information indicating that `9999` represents \"No Data\". To associate the information with the raster, we must write it to file along with the corresponding metadata. For example, to write the cropped raster to file, we need to modify the \"No Data\" setting in the metadata:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nout_meta = src_srtm.meta\nout_meta.update(nodata=9999)\nout_meta\n```\n\n::: {.cell-output-display execution_count=9}\n```\n{'driver': 'GTiff',\n 'dtype': 'uint16',\n 'nodata': 9999,\n 'width': 465,\n 'height': 457,\n 'count': 1,\n 'crs': CRS.from_epsg(4326),\n 'transform': Affine(0.0008333333332777796, 0.0, -113.23958321278403,\n        0.0, -0.0008333333332777843, 37.512916763165805)}\n```\n:::\n:::\n\n\nThen we can write the cropped raster to file:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nnew_dataset = rasterio.open(\"output/srtm_masked.tif\", \"w\", **out_meta)\nnew_dataset.write(out_image_mask)\nnew_dataset.close()\n```\n:::\n\n\nNow we can re-import the raster:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nsrc_srtm_mask = rasterio.open(\"output/srtm_masked.tif\")\n```\n:::\n\n\nThe `.meta` property contains the `nodata` entry. Now, any relevant operation (such as plotting) will take \"No Data\" into account:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsrc_srtm_mask.meta\n```\n\n::: {.cell-output-display execution_count=12}\n```\n{'driver': 'GTiff',\n 'dtype': 'uint16',\n 'nodata': 9999.0,\n 'width': 465,\n 'height': 457,\n 'count': 1,\n 'crs': CRS.from_epsg(4326),\n 'transform': Affine(0.0008333333332777796, 0.0, -113.23958321278403,\n        0.0, -0.0008333333332777843, 37.512916763165805)}\n```\n:::\n:::\n\n\nCropping means reducing the raster extent to the extent of the vector layer:\n\n* To crop *and* mask, we can use the same in `rasterio.mask.mask` expression shown above for masking, just setting `crop=True` instead of `crop=False`. \n* To just crop, *without* masking, we can derive the extent polygon and then crop using it.\n\nFor example, here is how we can obtain the extent polygon of `zion`, as a `shapely` geometry object:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nbb = zion.unary_union.envelope\nbb\n```\n\n::: {.cell-output-display execution_count=13}\n![](06-raster-vector_files/figure-html/cell-14-output-1.svg)\n:::\n:::\n\n\nThe extent can now be used for masking. Here, we are also using the `all_touched=True` option so that pixels partially overlapping with the extent are included:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nout_image_crop, out_transform_crop = rasterio.mask.mask(\n    src_srtm, \n    [bb], \n    crop=True, \n    all_touched=True, \n    nodata=9999\n)\n```\n:::\n\n\nFigure ... shows the original raster, and the cropped and masked results.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfig, axes = plt.subplots(ncols=3, figsize=(9,5))\nshow(src_srtm, ax=axes[0])\nzion.plot(ax=axes[0], color=\"none\", edgecolor=\"black\")\nshow(src_srtm_mask, ax=axes[1])\nzion.plot(ax=axes[1], color=\"none\", edgecolor=\"black\")\nshow(out_image_crop, transform=out_transform_crop, ax=axes[2])\nzion.plot(ax=axes[2], color=\"none\", edgecolor=\"black\")\naxes[0].set_title(\"Original\")\naxes[1].set_title(\"Mask\");\naxes[2].set_title(\"Crop\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](06-raster-vector_files/figure-html/cell-16-output-1.png){width=741 height=307}\n:::\n:::\n\n\n## Raster extraction\n\nFrom points...\n\nFrom line...\n\nFrom polygon (srtm)...\n\nFrom polygon (nlcd)...\n\n## Rasterization\n\n## Spatial vectorization\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nsrc = rasterio.open(\"data/grain.tif\")\n```\n:::\n\n\n## Exercises\n\n",
    "supporting": [
      "06-raster-vector_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}