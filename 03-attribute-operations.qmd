# Attribute data operations {#attr}

## Prerequisites

```{python}
#| echo: false
import pandas as pd
import matplotlib.pyplot as plt
pd.options.display.max_rows = 6
pd.options.display.max_columns = 6
pd.options.display.max_colwidth = 35
plt.rcParams["figure.figsize"] = (5, 5)
```

Packages...

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import geopandas as gpd
import rasterio
```

Sample data...

```{python}
#| echo: false
from pathlib import Path
data_path = Path("data")
file_path = Path("data/landsat.tif")
if not file_path.exists():
  if not data_path.is_dir():
     os
     os.mkdir(data_path)
  import os
  print("Attempting to get the data")
  import requests
  r = requests.get("https://github.com/geocompr/py/releases/download/0.1/landsat.tif")  
  with open(file_path, "wb") as f:
    f.write(r.content)
```

```{python}
world = gpd.read_file("data/world.gpkg")
src_elev = rasterio.open("data/elev.tif")
src_multi_rast = rasterio.open("data/landsat.tif")
```

## Introduction

...

## Vector attribute manipulation

As mentioned previously (...), vector layers (`GeoDataFrame`, from package `geopandas`) are basically extended tables (`DataFrame` from package `pandas`), the difference being that a vector layer has a geometry column. Since `GeoDataFrame` extends `DataFrame`, all ordinary table-related operations from package `pandas` are supported for vector laters as well, as shown below.

### Vector attribute subsetting

`pandas` supports several subsetting interfaces, though the most [recommended](https://stackoverflow.com/questions/38886080/python-pandas-series-why-use-loc) ones are:

* `.loc`, which uses pandas indices, and
* `.iloc`, which uses (implicit) numpy-style numeric indices.

In both cases the method is followed by square brackets, and two indices, separated by a comma. Each index can comprise:

* A specific value, as in `1`
* A slice, as in `0:3`
* A `list`, as in `[0,2,4]`
* `:`â€”indicating "all" indices

The once exception which we are going to with subsetting by indices is when selecting columns, directly using a list, as in `df[["a","b"]]`, instead of `df.loc[:, ["a","b"]]`, to select columns `"a"` and `"b"` from `df`.

Here are few examples of subsetting the `GeoDataFrame` of world countries.

Subsetting rows by position:

```{python}
world.iloc[0:3, :]
```

Subsetting columns by position:

```{python}
world.iloc[:, 0:3]
```

Subsetting rows and columns by position:

```{python}
world.iloc[0:3, 0:3]
```

Subsetting columns by name:

```{python}
world[["name_long", "geometry"]]
```

"Slice" of columns between given ones:

```{python}
world.loc[:, "name_long":"pop"]
```

Subsetting by a boolean series:

```{python}
x = np.array([1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], dtype=bool)
world.iloc[:, x]
```

We can remove specific columns using the `.drop` method and `axis=1` (i.e., columns):

```{python}
world.drop(["name_long", "continent"], axis=1)
```

We can rename (some of) the selected columns using the `.rename` method:

```{python}
world[["name_long", "pop"]].rename(columns={"pop": "population"})
```

The standard `numpy` comparison operators can be used in boolean subsetting, as illustrated in Table ...

TABLE ...: Comparison operators that return Booleans (TRUE/FALSE).

|`Symbol` | `Name` |
|---|---|
| `==` | Equal to |
| `!=` | Not equal to |
| `>`, `<` | Greater/Less than |
| `>=`, `<=` | Greater/Less than or equal |
| `&`, `|`, `~` | Logical operators: And, Or, Not |

A demonstration of the utility of using logical vectors for subsetting is shown in the code chunk below. This creates a new object, small_countries, containing nations whose surface area is smaller than 10,000 km^2^:

```{python}
i_small = world["area_km2"] < 10000  ## a logical 'Series'
small_countries = world[i_small]
small_countries
```

The intermediary `i_small` (short for index representing small countries) is a boolean `Series` that can be used to subset the seven smallest countries in the world by surface area. A more concise command, which omits the intermediary object, generates the same result:

```{python}
small_countries = world[world["area_km2"] < 10000]
```

The various methods shown above can be chained for any combination with several subsetting steps. For example:

```{python}
world[world["continent"] == "Asia"]  \
    .loc[:, ["name_long", "continent"]]  \
    .iloc[0:5, :]
```

### Vector attribute aggregation

Aggregation without geometry...

### Vector attribute joining

Join by attribute...

```{python}
coffee_data = pd.read_csv("data/coffee_data.csv")
coffee_data
```

Join by `"name_long"` column...

```{python}
world_coffee = pd.merge(world, coffee_data, on = "name_long", how = "left")
world_coffee
```

Plot... 

```{python}
base = world.plot(color = "white", edgecolor = "lightgrey")
world_coffee.plot(ax = base, column = "coffee_production_2017");
```


### Creating attributes and removing spatial information

Calculate new column...

```{python}
world2 = world.copy()
world2["pop_dens"] = world2["pop"] / world2["area_km2"]
```

Unite columns...

```{python}
world2["con_reg"] = world["continent"] + ":" + world2["region_un"]
world2 = world2.drop(["continent", "region_un"], axis=1)
```

Split column...

```{python}
world2[["continent", "region_un"]] = world2["con_reg"].str.split(":", expand=True)
```

Rename...

```{python}
world2.rename(columns={"name_long": "name"})
```

Renaming all columns...

```{python}
new_names =["i", "n", "c", "r", "s", "t", "a", "p", "l", "gP", "geom"]
world.columns = new_names
```

Dropping geometry...

```{python}
pd.DataFrame(world.drop(columns="geom"))
```

## Manipulating raster objects

### Raster subsetting

When using `rasterio`, raster values are accessible through a `numpy` array, which can be imported with the `.read` method:

```{python}
elev = src_elev.read(1)
elev
```

Then, we can access any subset of cell values using `numpy` methods. For example:

```{python}
elev[0, 0]  ## Value at row 1, column 1
```

Cell values can be modified by overwriting existing values in conjunction with a subsetting operation. The following expression, for example, sets the upper left cell of elev to 0:

```{python}
elev[0, 0] = 0
elev
```

Multiple cells can also be modified in this way:

```{python}
elev[0, 0:2] = 0
elev
```

### Summarizing raster objects

Global summaries of raster values can be calculated by applying `numpy` summary functions---such as `np.mean`---on the array with raster values. For example:

```{python}
np.mean(elev)
```

Note that "No Data"-safe functions--such as `np.nanmean`---should be used in case the raster contains "No Data" values which need to be ignored:

```{python}
elev[0, 2] = np.nan
elev
```

```{python}
np.mean(elev)
```

```{python}
np.nanmean(elev)
```

Raster value statistics can be visualized in a variety of ways. One approach is to "flatten" the raster values into a one-dimensional array, then use a graphical function such as `plt.hist` or `plt.boxplot` (from `matplotlib.pyplot`). For example:

```{python}
x = elev.flatten()
plt.hist(x);
```

## Exercises


